<!DOCTYPE html>
<html>
  <head>
    <title>The open mainframe architecture</title>
    <style>
@media print {
h1 {
  page-break-before: always;
}
h1:first-child {
  page-break-before: avoid;
}
}
html {
  font-family: serif;
  font-size: 16px;
}
body {
  counter-reset: chapter figure;
  padding: 10px 2%;
}
h1 {
  counter-reset: section;
}
h2 {
  counter-reset: subsection;
}
h1::before {
  counter-increment: chapter;
  content: counter(chapter) ". ";
}
h2::before {
  counter-increment: section;
  content: counter(chapter) "." counter(section) " ";
}
h3::before {
  counter-increment: subsection;
  content: counter(chapter) "." counter(section) "." counter(subsection) " ";
}
code {
  white-space: pre;
}
p {
  margin: 0.25em 0;
}
pre {
  margin-left: 0.5em;
  font-size: 80%;
}
figure {
  counter-increment: figure;
  text-align: center;
}
figure figcaption {
  margin-top: 0.25em;
}
figure figcaption::before {
  content: "figure " counter(figure) ": ";
}

.inline {
  display: inline-block;
}
.unnumbered::before {
  counter-increment: none;
  content: '';
}

.comment {
  color: green;
  font-style: italic;
}
.keyword {
  color: blue;
}
.literal {
  color: brown;
  white-space: pre;
}
.reserved {
  color: purple;
}
.variable {
  font-style: italic;
}
.variable::before {
  content: "\00AB";
}
.variable::after {
  content: "\00BB";
}

.entity {
  border: solid thin;
  box-shadow: 2px 2px 2px #666;
  border-radius: 10px;
  display: inline-block;
  padding: 4px;
}
.entity sub {
  font-size: 60%;
}
.entity-isolated {
  margin: 0 1em;
}
.entity-middle {
  margin: 0 0.25em;
}
.entity-right {
  margin: 0 1em 0 0.25em;
}
.entity-left {
  margin: 0 0.25em 0 1em;
}
.boundary {
  border-style: solid;
  border-width: 0;
  text-align: right;
}
.boundary span {
  font-style: italic;
  margin-right: -4em;
}
.backend {
  border-bottom-width: thin;
}
.frontend {
  border-top-width: thin;
}

.widget, .node {
  border: solid thin;
  display: inline-block;
  margin: 6px;
  padding: 4px;
}
.widget {
  border-radius: 2px;
}
.node {
  min-width: 3em;
}
.internal {
  border-radius: 2px;
}
.leaf {
  border-radius: 16px;
}
.path {
  font-weight: bold;
}

.network-stack {
  border-spacing: 0;
  border-collapse: collapse;
}
.network-stack td {
  text-align: center;
}
.layer td {
  padding: 0.25em;
  border-width: thin 0;
}
.firewall.layer td {
  border-style: solid;
  border-width: thin;
  background-color: #f0f0f0;
  font-style: italic;
}
.network.layer td {
  border-style: solid;
}
.network-flow {
  font-size: 0.5em;
}
.layer td.network-separator {
  border-bottom-style: none;
  border-top-style: none;
  background-color: inherit;
}

.rule-condition {
  margin-left: 0.5em;
  margin-right: 2em;
}
.rule-condition:after {
  content: '\21d2';
  display: inline-block;
  margin-left: 2em;
}

.delta-side, .delta-message, .bad-side {
  display: inline-block;
  text-align: center;
}
.delta-side, .bad-side {
  width: 4em;
}
.delta-side {
  border: solid thin;
  border-radius: 2px;
  padding: 0.25em 0;
}
.delta-message {
  line-height: 90%;
  margin: 0 1em;
  vertical-align: middle;
  width: 6em;
}
    </style>      
  </head>
  <body>
    <h1 class="unnumbered">Preface</h1>
    <p>
I am a seasoned software developer from The Netherlands. I hope you have an interest in the development of interactive applications.
    </p>
    <p>
In this document, I describe an architecture for interactive applications. Although mainframes and terminals sound outdated, I will show they are relevant concepts in the 21st century. I am however not suggesting we should dust off mainframes and put them back in business. The open mainframe architecture (oma) recycles the idea of a reliable, scalable mainframe that serves stateless terminals, but an open mainframe employs modern web technologies to implement this old idea. The word 'oma' means granny or grandmother in Dutch. This seems fitting for an architecture that is based on decades-old concepts.
    </p>
    <p>
An open mainframe is a web server. A web browser turns into a terminal when it visits a web site on an open mainframe. A terminal is the ultimate thin client whose sole responsibility is the presentation of a user interface. Terminals are application agnostic. A mainframe hosts applications that process user interactions for terminals. The strict separation of presentation and application concerns is the essence of mainframes and terminals.
    </p>
    <p>
The open mainframe architecture is released under the liberal MIT license. The reference implementation of oma complements this document with an executable prototype in JavaScript (Node.js). Developers are encouraged to implement oma components in their favorite programming languages. The ability to mix and match heterogenous components in an architecture for interactive applications is the primary goal of oma. In memory of Douglas Adams, oma adopts the slogan of the Sirius Cybernetics Corporation. Share and enjoy!
    </p>
    <h1>Introduction</h1>
    <p>
The open mainframe architecture revives old ideas. In this chapter, I take a trip down memory lane.
    </p>
    <h2>Mainframes and terminals</h2>
    <p>
Mainframes are the first commercial computers. They are mysterious machines in the 1950s and 60s, because electronics is still in its infancy. Mainframes automate administrative tasks, often in the finance industry. Mainframes have almost become extinct, but they remain renowned for their reliability.
    </p>
    <figure>
      <img src="http://upload.wikimedia.org/wikipedia/commons/7/7d/IBM_704_mainframe.gif" />
      <figcaption>IBM 704 mainframe at Lawrence Livermore National Laboratory, 1964 (<a href="http://commons.wikimedia.org/wiki/File:IBM_704_mainframe.gif#/media/File:IBM_704_mainframe.gif">Wikimedia</a>)</figcaption>
    </figure>
    <p>
A terminal displays the user interface of a remote process that is running on a mainframe. The first terminals are primitive teletypewriters. Later models introduce monochrome monitors. Despite a hefty price tag, a terminal is still relatively inexpensive compared to a mainframe. Organizations can upgrade their terminals without additional investments in their mainframes.
    </p>
    <figure>
      <img src="http://upload.wikimedia.org/wikipedia/commons/thumb/2/23/Vt100-adventure.jpg/220px-Vt100-adventure.jpg" />
      <figcaption>DEC VT101 terminal (<a href="http://en.wikipedia.org/wiki/VT100#/media/File:Vt100-adventure.jpg">Wikimedia</a>)</figcaption>
    </figure>
    <p>
Mainframes and terminals revolutionize the concept of remote computing. A mainframe runs processes whose user interfaces are displayed on terminals. A terminal reports user interactions to a remote process. The process computes the effects of the interactions on the user interface. These effects are communicated back to the terminal that updates the user interface accordingly. Mainframes and terminals respect a strict separation of presentation and application concerns. A process on the mainframe is a running instance of an application, which decides how a user interface responds to interactions. A terminal decides how a user interface is presented on a physical display.
    </p>
    <h2>Home computers and PCs</h2>
    <p>
In the early 1980s, a new type of computer emerges. The home computer inspires enthusiasts to learn more about hardware and software. The computational power of a home computer is tiny, but creative minds manage to squeeze out every inch of the hardware to create impressive games and demos. User experience is important for applications on home computers. Users are no longer bank employees that blindly accept how a mainframe application works. Users are critical consumers that need convincing before they buy an application.
    </p>
    <figure>
      <img src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/34/Commodore-64-Computer.png/300px-Commodore-64-Computer.png" />
      <figcaption>Commodore 64 (<a href="http://en.wikipedia.org/wiki/Commodore_64#/media/File:Commodore-64-Computer.png">Wikimedia</a>)</figcaption>
    </figure>
    <p>
The personal computer dominates after the home computer. The affordable PC introduces computers to a broad audience. The competitive PC market forces hardware and software manufacturers to innovate. Ergonomics and usability studies are taken seriously. New technologies, e.g. mouse, color display and audio playback, pave the way for immersive user interfaces. For many people, the PC becomes a vital instrument that is switched on every day.
    </p>
    <figure>
      <img src="http://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/MSI_Laptop_computer.jpg/220px-MSI_Laptop_computer.jpg" />
      <figcaption>Laptop PC (<a href="http://en.wikipedia.org/wiki/Personal_computer#/media/File:MSI_Laptop_computer.jpg">Wikimedia</a>)</figcaption>
    </figure>
    <p>
Home computers and PCs shift attention from machines to humans. Software should keep users happy and productive on commodity hardware. Most consumers are not interested in the details of the hardware they own. They only care for the applications they can run on the hardware.
    </p>
    <h2>Networking and the Internet</h2>
    <p>
A new problem surfaces when businesses connect the PCs of employees to a network. Distributed application management is a nightmare on a network with PCs. An upgrade of a service on the business network, e.g. a new print server, might demand an update of the client software on all PCs. Members of the IT department regularly hop from PC to PC in a building, installing new software versions by hand. 
    </p>
    <figure>
      <img src="http://upload.wikimedia.org/wikipedia/commons/thumb/a/aa/Floppy_disk_2009_G1.jpg/220px-Floppy_disk_2009_G1.jpg" />
      <figcaption>Floppies for software distribution (<a href="http://en.wikipedia.org/wiki/Floppy_disk#/media/File:Floppy_disk_2009_G1.jpg">Wikimedia</a>)</figcaption>
    </figure>
    <p>
The Internet provides a solution with web applications. A PC runs a web browser  that displays HTML pages of a web application. The user can install other software on the PC. The web application is hosted and maintained on a web server. The first web applications are restricted to simple form-based tasks. Improved web standards, and better support for existing standards across browsers, enable web applications to offer a decent user experience for a wide range of tasks on PCs with mainstream browsers.
    </p>
    <figure>
      <img src="http://upload.wikimedia.org/wikipedia/en/thumb/c/c9/Navigator_1-22.png/225px-Navigator_1-22.png" />
      <figcaption>Netscape Navigator 1.22 (<a href="http://en.wikipedia.org/wiki/Netscape_Navigator#/media/File:Navigator_1-22.png">Wikimedia</a>)</figcaption>
    </figure>
    <p>
Web browsers that display HTML pages, are similar to terminals that display user interfaces, although browsers blur the separation between presentation and application concerns. A terminal presents a user interface whose state is completely controlled by the process on the mainframe. A browser is on the other hand able to respond to user interactions by executing JavaScript code that updates the user interface, without informing the server. Web applications on servers cannot always reproduce the complete state of a user interface that a web browser currently presents.
    </p>
    <h2>Apps on mobile devices</h2>
    <p>
Web applications are not popular on mobile devices, because native apps deliver a superior user experience. Web standards are still playing catch-up with mobile technologies. It's an unfortunate consequence of the standardization process. A rivalry with native apps is out of the question, if web applications are not exploiting basic features on mobile devices, e.g. touch and orientation. The loss in user experience is unacceptable.
    </p>
    <figure>
      <img src="http://upload.wikimedia.org/wikipedia/commons/thumb/8/8a/ASUS_Mobile_ZenFone6_20141109.jpg/150px-ASUS_Mobile_ZenFone6_20141109.jpg" />
      <figcaption>Android smartphone (<a href="http://en.wikipedia.org/wiki/Smartphone#/media/File:ASUS_Mobile_ZenFone6_20141109.jpg">Wikimedia</a>)</figcaption>
    </figure>
    <p>
Apps on mobile devices resemble PC applications, because both execute on personal devices, but their distribution methods are vastly different. A user installs a PC application from a storage medium. An app is distributed from a central app store. App stores give device vendors tight control over application distribution and installation. Most users on mobile devices have given up the freedom to install software as they please. They trust app stores to manage and to upgrade applications for them.
    </p>
    <h2>Summary</h2>
    <p>
The short history of application architectures shows an interesting tug of war between application management and user experience.
    </p>
    <ul>
      <li>
        <p>
Application management is easy on mainframes, but the user experience on terminals is bad.
        </p>
      </li>
      <li>
        <p>
PC applications offer a great user experience, but it is hard to manage applications in a network with PCs.
        </p>
      </li>
      <li>
        <p>
Web applications are easy to manage on servers, but web browsers offer a poor user experience on mobile devices.
        </p>
      </li>
      <li>
        <p>
Native apps offer a rich user experience on mobile devices, but application management must be delegated to app stores.
        </p>
      </li>
    </ul>
    <h1>Overview</h1>
    <p>
This chapter explains how the major components of oma fit together.
    </p>
    <h2>Presentation and application concerns</h2>
    <p>
The open mainframe architecture consists of a presentation and application tier. The presentation tier is where terminals live. A terminal renders a user interfaces and it reports user interactions. The application tier is where processes live. A process is a running instance of an application, which controls the state of a user interface. When a terminal reports user interactions, the process updates the user interface.
    </p>
    <p>
A traditional mainframe runs all processes for connected terminals. A traditional mainframe <em>is</em> the application tier. An open mainframe is a router between tiers. An open mainframe does <em>not</em> execute application logic on behalf of terminals. All processes run autonomously in the backend of an open mainframe. Terminals execute their presentation logic in the frontend. The open mainframe in the middle provides reliable communication between frontend and backend networks.
    </p>
    <p>
Applications are installed on a traditional mainframe, much like PC applications, but applications on an open mainframe are deployed from the backend. When a frontent terminal launches an application that has been deployed from the backend, the deployment creates a backend process. The new process computes the initial state of a user interface, which is communicated back to the terminal and presented to the user.
    </p>
    <figure>
      <div class="inline">
        <div class="inline entity-isolated">
          <span class="entity">term<sub>1</sub></span><br/>
          &dArr;<br/>
        </div>
        <div class="inline entity-isolated">
          <span class="entity">term<sub>2</sub></span><br/>
          &dArr;<br/>
        </div>
        <div class="inline entity-isolated">
          <span class="entity">term<sub>3</sub></span><br/>
          &dArr;<br/>
        </div>
        <div class="boundary frontend"><span>frontend boundary</span></div>
        open mainframe
        <div class="boundary backend"><span>backend boundary</span></div>
        <div class="inline entity-left">
          &dArr;<br/>
          <span class="entity">proc<sub>1.1</sub></span><br/>
        </div>
        <div class="inline entity-middle">
          &uArr;<br/>
          <span class="entity">app<sub>1</sub></span><br/>
        </div>
        <div class="inline entity-right">
          &dArr;<br/>
          <span class="entity">proc<sub>1.2</sub></span><br/>
        </div>
        <div class="inline entity-left">
          &uArr;<br/>
          <span class="entity">app<sub>2</sub></span><br/>
        </div>
        <div class="inline entity-right">
          &dArr;<br/>
          <span class="entity">proc<sub>2.1</sub></span><br/>
        </div>
        <div class="inline entity-isolated">
          &uArr;<br/>
          <span class="entity">app<sub>3</sub></span><br/>
        </div>
      </div>
      <figcaption>Frontend and backend</figcaption>
    </figure>
    <p>
Backend applications and processes are not concerned with particular user-interface technologies. Frontend terminals don't care about application logic to process user interactions. Traditional and open mainframes respect the same separation of presentation and application concerns. The open mainframe architecture inserts an extra router to improve scalability, but this does not affect the primary separation of concerns.
    </p>
    <h2>Web technologies</h2>
    <p>
Unlike traditional mainframes with proprietary technologies, oma embraces open web technologies and standards. Terminals, applications and processes are HTTP clients that talk to web services on an open mainframe. The open mainframe architecture leverages the success of HTTP. Common problems, e.g. HTTPS encryption, serving static files and load balancing, have already been solved in numerous hardware and software products. The challenge is to encorporate these products in the infrastructure of oma as smoothly as possible. Reliance on HTTP for all communication ensures HTTP-based products work equally well in frontend and backend networks.
    </p>
    <p>
A web browser turns into a frontend terminal when a user navigates the browser to the welcome service on an open mainframe. Browsers are converging towards an impressive set of HTML standards and APIs. CSS has also been steadily improving over the years, gaining ever more features to separate styling from content. The browser wars have ended in a victory for web standards.
    </p>
    <p>
Despite a problematic childhood, JavaScript has matured well. Every incarnation of oma ships with a Node.js implementation. The sole purpose of this reference implementation is to provide an executable prototype of the architecture. JavaScript is the obvious choice for a reference implementation, because web browsers must be programmed in JavaScript. There is no compelling reason to complicate the reference implementation with another programming language.
    </p>
    <p>
JSON is the preferred data format. The open mainframe architecture extends JSON with a type system to enforce more rigorous rules about structure. JSON with datatypes is an essential ingredient that glues the components of oma together. The type system introduces a simple definition language to create datatypes, which specify how to marshal and unmarshal data values in JSON.
    </p>
    <h2>Web services</h2>
    <p>
An open mainframe implements the following web services for HTTP clients in frontend and backend networks.
    </p>
    <ul>
      <li>
        <p>
library service
        </p>
        <p>
This service resembles a public library where any client can read books, known as bundles in oma terminology. A <dfn>bundle</dfn> publishes assets in a directory on a web server. Bundles are distribution units for modules. When a client needs a module from a bundle, it fetches all modules of the bundle in one download.
        </p>
        <p>
If a bundle is like a book, a module is like a chapter in a book. A <dfn>module</dfn> is a logically cohesive set of assets with a clear purpose. A modular organization reduces complexity of asset management. Developers should not care about the bundles in which their modules are distributed. This flexibility promotes the development of many small modules that specify their dependencies on other modules.
        </p>
        <p>
A browser loads modules from standard library bundles, which transform the browser into a booting terminal. These modules initialize a JavaScript runtime environment that enables the terminal to connect to a remote mainframe.
        </p>
      </li>
      <li>
        <p>
delta service
        </p>
        <p>
This service creates delta sessions. A <dfn>delta session</dfn> synchronizes a typed JSON model that the client and server side of the session share. The client side sends a delta request with actions on the model. A delta action is either a mutation that modifies the model, or an event that signals an incident in the model. The server side replies with a delta response whose actions reflect the effects of processing the previous request. The sequential exchange of delta messages continues, until one of the sides closes the session.
        </p>
        <p>
The direction of a delta session determines the role of an HTTP client in the session. Terminal and application sessions are <dfn>forward sessions</dfn>. Terminals and applications are HTTP clients that fulfil the client role in delta sessions. Processes are also HTTP clients, but they play the server role in delta sessions. Process sessions are <dfn>reverse sessions</dfn>.
        </p>
      </li>
      <li>
        <p>
welcome service
        </p>
        <p>
The welcome service establishes contact between a terminal and an open mainframe. When a user navigates a web browser to this service, the browser becomes a terminal that requests the welcome service to launch an application. The service examines the welcome request to determine the deployed application that the user intends to start.
        </p>
        <p>
When a user starts an application, a new terminal session in the frontend is paired with a new process session in the backend. A <dfn>session pair</dfn> synchronizes the same model in opposite directions. The forward terminal session controls the client side of the model and the reverse process session controls the server side. The open mainframe relays delta messages between the client and server side of a session pair.
        </p>
      </li>
      <li>
        <p>
deploy service
        </p>
        <p>
This service deploys backend applications on an open mainframe. An HTTP client posts a request to the service with a description of the application to deploy from the backend. Successful deployment results in a new application session. Delta actions in this session instruct the backend application to create new processes, when terminals launch the application.
        </p>
      </li>
      <li>
        <p>
diagnostics service
        </p>
        <p>
Components in a perfect architecture are black boxes with hidden implementations, but the diagnostics service in oma offers a peek inside to expose some inner workings. This service supplies metrics about the performance and load of an open mainframe. Diagnostics clients monitor the health of an open mainframe. They should detect minor issues before they turn into major problems.
        </p>
      </li>
    </ul>
    <p>
The <dfn>mainframe root</dfn> is the URL where an open mainframe is located from the perspective of an HTTP client, e.g. <code>http://example.oma/</code>. Most URLs in this document are relative to a mainframe root.
    </p>
    <p>
A <dfn>welcome URL</dfn> is displayed in the navigation bar of a terminal. A welcome URL involves a user experience. A user that bookmarks a welcome URL, expects to see a similar user interface when the bookmark is activated later on. Welcome URLs should be semantic, but oma cannot dictate the logical structure of a <a href="http://en.wikipedia.org/wiki/Semantic_URL">semantic URL</a>, because it depends on the application domain. An application specifies patterns of welcome URLs that belong to the deployment.
    </p>
    <p>
A <dfn>service URL</dfn> is part of a web service. An underscore in the mainframe root is the home directory where all web services are located. For example, <code>_/pub/</code> is the location where the library service publishes bundles.
    </p>
    <p>
An <dfn>asset URL</dfn> locates an asset that belongs to a module. It is a relative URL that starts with a tilde, followed by the module name and the path to the asset. Asset URL <code>~My.Example/i/cat.png</code> locates asset <code>i/cat.png</code> in module <code>My.Example</code>.
    </p>
    <p>
The <dfn>application image</dfn> of a deployment lists all modules that a terminal may need to load when it launches the application. Application images control the translation of asset URLs to service URLs. If an application image specifies that module <code>My.Example</code> is published as the fifth module in bundle <code>my-example</code> with release id <code>qL8C3</code>, the previous asset URL translates to <code>_/pub/my-example/qL8C3/5/i/cat.png</code>. An asset URL is automatically translated to a service URL of a published asset, when the content of the asset is needed.
    </p>
    <h2>Virtual user interface</h2>
    <p>
The JSON model of a terminal session holds a virtual user interface. The terminal shares this model with a backend process whose session is paired with the terminal session. The terminal translates real user interactions to delta actions on the virtual user interface. The process updates the virtual user interface in response to these interactions. The terminal ensures the real user interface is refreshed to manifest the new state of the virtual user interface.
    </p>
    <p>
A virtual user interface must consider the impact of the network on the user experience. When a user interaction takes place in a terminal, there is a network delay before a backend process is informed about a delta action in a virtual user interface. There is yet another network delay before the effects in the virtual user interface are reported back to the frontend terminal and manifested in the real user interface. Network delays are measured in milliseconds. This differs significantly from delays in native window systems that deliver user-interface events in microseconds.
    </p>
    <p>
The state of a virtual user interface is a typed data value. The bulk of this state is taken up by a tree structure with virtual widgets. A <dfn>layout widget</dfn> specifies a layout strategy for child widgets. A <dfn>decorator widget</dfn> adds a feature to a child widget. An <dfn>output widget</dfn> displays a non-interactive text or image. An <dfn>input widget</dfn> translates user interactions to delta actions.
    </p>
    <figure>
    <span class="widget">layout</span><br/>
    <span>&#8601;<span style="margin: auto 2em;">&#8595;</span>&#8600;</span><br/>
    <span class="widget">label</span> <span class="widget">decorator</span> <span class="widget">label</span><br/>
    <span>&#8595;</span><br/>
    <span class="widget">text input</span><br/>
    <figcaption>Widget tree in session model</figcaption>
    </figure>
    <p>
A terminal loads modules that define datatypes for virtual widgets. The terminal loads other modules that implement real widgets in JavaScript. A <dfn>manifestation</dfn> determines how a data value in a session model behaves in a runtime environment. Manifestations separate structural from behavioral concerns. A virtual slider widget in a session model is unaware of its manifestation in a terminal environment, which manipulates the DOM of a web browser to create a real slider that the user can interact with.
    </p>
    <p>
The datatypes of virtual widgets are annotated to specify characteristics in a delta session. These annotations define whether the client, the server, or both sides of the session can modify a widget. By default, the server side can alter a widget, but the client cannot. The datatype of a text input must be annotated to be modifiable on the client side. Otherwise the terminal cannot modify an input widget in the tree, when the user enters a new text.
    </p>
    <p>
Type annotations distinguish between persistent mutations and transient events. An event signals an incident, but the incident is not persisted in the widget tree. When a terminal reports a button click event, the process does not have to 'unclick' the button widget, because the state of a virtual button does not change after clicking the button. 
    </p>
    <p>
Type annotations furthermore specify how the terminal reacts to a mutation or event on the client side. The default reaction is immediate and non-blocking. A terminal informs the process about a user interaction as soon as possible. While waiting for the process to compute the effects of the interaction, the terminal presents a responsive user interface. If the client reaction is specified as blocking, the terminal immediately locks the user interface, and unlocks it after the process has responded to the blocking interaction.
    </p>
    <p>
A non-blocking reaction is not necessarily immediate. Type annotations can specify a client side that buffers a mutation or event. When the client is about to send the next delta request, it flushes the buffer and adds the flushed delta actions to the request on the wire. The server side is not informed about buffered actions until the client flushes. 
    </p>
    <p>
A terminal session cannot prevent synchronization conflicts, because the terminal is allowed to change the session model while waiting for the backend process to produce a delta response. For example, when a terminal is expecting a delta response from the process, and the user changes the text of a text input widget, the actions in the subsequent response can remove the input widget from the virtual user interface. The server side always wins these conflicts. The client side must drop the invalidated mutations and events.
    </p>
    <p>
The model of a session pair has one state, but when a terminal buffers user interactions, the virtual user interface appears to be in two different states. The process controls the old state, before the interactions, while the terminal is already presenting the new state. The terminal is however presenting an intermediate state that will be synchronized with the process in due time. Every delta message has a lease time that specifies how many seconds the receiver of the message can wait, before it has to send the next delta message. Upon lease expiration, the terminal sends one delta request to transition the model to a new state, which combines all intermediate states that have already been presented.
    </p>
    <p>
A terminal should not buffer an interaction if the process might respond to the interaction with an update in the widget tree. Intermediate states must represent insignificant interactions in the application domain.
    </p>
    <h2>Multidisciplinary teams</h2>
    <p>
Application development is difficult in any architecture. It's a delicate sport that requires experts from different disciplines and backgrounds to cooperate effectively in a team. In my experience, it's very rare to find a team that operates without problems. These problems have diverse reasons, e.g. procedural, personal or technical. The open mainframe architecture balances the needs of all team disciplines that are involved in an application's lifecycle, but it can only assist disciplines on technical grounds. The nontechnical challenges of a development process are outside the scope of oma.
    </p>
    <p>
For the sake of simplicity, I assume there are four disciplines in a development team. The <dfn>frontend developer</dfn> is responsible for assets in modules, which manifest virtual widgets in a browser environment. The <dfn>backend developer</dfn> writes application logic to control virtual user interfaces. The <dfn>QA engineer</dfn> verifies quality of application deployments before they go into production. An <dfn>infrastructure engineer</dfn> builds the infrastructure of open mainframes for development, test and production purposes.
    </p>
    <p>
Frontend and backend developers share a <dfn>development mainframe</dfn> on which they deploy and test applications. Developers do not have to maintain and run an open mainframe on their local machines. They simply post an HTTP request to the deploy service on the development mainframe. After successful deployment, developers start an application by navigating a web browser to a welcome URL on the development mainframe.
    </p>
    <p>
Developers have to agree on the application image that defines which module versions are bundled in an application deployment. Backend developers are unlikely to change an application image when they deploy new application logic. It might even be possible to test a new version of the application without redeploying it. Frontend developers redeploy the same application logic over and over again, but with different images, to test new manifestations in browser environments. The source assets of these manifestations are uploaded in heavy deployments. A <dfn>heavy deployment</dfn> contains modules that have not yet been published in library bundles. Heavy deployments allow frontend developers to replace modules in an application image. They test the new modules until they are satisfied with the result. Once the modules have been published in library bundles, the new bundle versions can be referenced from 'light' deployments. 
    </p>
    <p>
The early stages of an application's lifecycle focus on frantic development, but at some point, an application deployment should be production-ready. A <dfn>test mainframe</dfn> isolates application deployments. New application versions have to pass a slew of quality assurance tests before they go into production. Users can start a particular version in a terminal and test it, if the version is reachable at some welcome URL on the test mainframe. The isolation of datasets and of application code in distinct deployments is a responsibility of QA engineers. 
    </p>
    <p>
Infrastructure engineers are not confronted with a myriad of protocols and technologies, because all communication in oma is based on HTTP. Large Internet companies demonstrate every day that HTTP, and HTTPS, scales to millions of connections. The figure shows the network topology of a typical <dfn>production mainframe</dfn>. An arrow is the initiation of a TCP connection between networks. The mainframe network is a demilitarized zone (DMZ), separated from frontend and backend networks. The frontend firewall filters connections from the Internet, it handles encryption of HTTPS connections and it serves static assets. Other HTTP requests from the Internet are forwarded to an address, or multiple addresses, in the mainframe network. Backend firewalls similarly filter, forward and balance HTTP requests from networks where the processes of deployed applications are running. 
    </p>
    <figure>
      <table class="inline network-stack">
        <tbody>
          <tr class="network layer">
            <td colspan="7">
Internet
            </td>
          </tr>
          <tr class="network-flow">
            <td colspan="7">
&darr;
            </td>
          </tr>
          <tr class="firewall layer">
            <td colspan="7">
frontend firewall
            </td>
          </tr>
          <tr class="network-flow">
            <td colspan="2">
&darr;
            </td>
            <td colspan="3">
&darr;
            </td>
            <td colspan="2">
&darr;
            </td>
          </tr>
          <tr class="network layer">
            <td colspan="7">
mainframe network
            </td>
          </tr>
          <tr class="network-flow">
            <td>
&uarr;
            </td>
            <td>
&uarr;
            </td>
            <td>
&uarr;
            </td>
            <td class="network-separator" />
            <td>
&uarr;
            </td>
            <td>
&uarr;
            </td>
            <td>
&uarr;
            </td>
          </tr>
          <tr class="firewall layer">
            <td colspan="3">
backend firewall<sub>1</sub>
            </td>
            <td class="network-separator" />
            <td colspan="3">
backend firewall<sub>2</sub>
            </td>
          </tr>
          <tr class="network-flow">
            <td colspan="3">
&uarr;
            </td>
            <td class="network-separator" />
            <td colspan="3">
&uarr;
            </td>
          </tr>
          <tr class="network layer">
            <td colspan="3">
app network<sub>1</sub>
            </td>
            <td class="network-separator" />
            <td colspan="3">
app network<sub>2</sub>
            </td>
          </tr>
        </tbody>
      </table>
      <figcaption>Network topology of production mainframe</figcaption>
    </figure>
    <h2>Summary</h2>
    <p>
The open mainframe architecture separates presentation from application concerns, in the same spirit as traditional mainframes. An open mainframe is a reliable, scalable platform that employs modern web technologies to bridge the gap between the presentation and application tier. Applications are deployed from the backend. They create processes that control virtual user interfaces for terminals. A web browser turns into a frontend terminal when it launches a deployed application. The user experience in virtual user interfaces depends on the quality of widgets. Frontend developers build widgets that backend developers include in virtual user interfaces.
    </p>
    <p>
Open mainframes come in various shapes and sizes, with different perspectives on application management. On a development mainframe, frontend and backend developers manage their own temporary application deployments. QA engineers isolate deployments of distinct application versions on a test mainframe before applications go into production. Production mainframes deploy the most recent application versions that passed all QA tests.
    </p>
    <h1>JSON with datatypes</h1>
    <p>
The open mainframe architecture adds a simple type system to JSON, which specifies how to marshal and unmarshal data values. A <dfn>basic value</dfn> is <code class="literal">null</code>, <code class="literal">true</code>, <code class="literal">false</code>, a number or a string. A <dfn>composed value</dfn> is a dictionary, a list or a record.
    </p>
    <h2>Datatypes</h2>
    <p>
The following datatypes define the structure of values.
    </p>
    <ul>
      <li>
        <p>
The basic types are <code>none</code>, <code>boolean</code>, <code>number</code> and <code>string</code>. Type <code>none</code> is the type of a <code class="literal">null</code> value.
        </p>
      </li>
      <li>
        <p>
Type <code>integer</code> is a subtype of <code>number</code> that covers integer numbers.
        </p>
      </li>
      <li>
        <p>
An enumeration type enumerates one or more distinct string choices. Enumerated choices are surrounded by double quotes and separated by underscores, e.g. <code>"a"_"b"_"c"</code>.
        </p>
      </li>
      <li>
        <p>
A wildcard type, denoted with an asterisk, matches types without a <code class="literal">null</code> value.
        </p>
      </li>
      <li>
        <p>
An optional type, denoted as a type with a closing question mark, adds a <code class="literal">null</code> value. An optional wildcard type <code>*?</code> matches any type.
        </p>
      </li>
      <li>
        <p>
A list type surrounds an element type with square brackets. A value of list type <code>[string?]</code> is a sequence of basic string and <code class="literal">null</code> values.
        </p>
      </li>
      <li>
        <p>
A dictionary type surrounds an element type with angle brackets. Dictionaries map strings to their elements. A value of dictionary type <code>&lt;number&gt;</code> maps string keys to basic numbers.
        </p>
      </li>
      <li>
        <p>
A record type surrounds comma-separated field definitions with curly brackets. A colon associates a name with a type in a field definition. Record type <code>{foo:[number]}</code> defines field <code>foo</code> whose value is a list with numbers.
        </p>
      </li>
      <li>
        <p>
A union type separates type alternatives with vertical bars. A value of union type <code>number|string</code> is either a basic number or string.
        </p>
      </li>
    </ul>
    <h2>Definition language</h2>
    <p>
A <dfn>typespace</dfn> binds names to type expressions and macros. A <dfn>type expression</dfn> is evaluated in a typespace. A <dfn>type macro</dfn> is a template that needs one or more type parameters to evaluate the resulting datatype. Typespaces add a convenient indirection to organize and to reuse type definitions in oma, for example type additions to merge the fields of record types.
    </p>
    <p>
The definitions in a typespace must be closed under evaluation. Every type variable in an expression must be bound to a macro argument. Every type name must be bound to a macro or expression in the typespace. The complete grammar of the type definition language is given below in EBNF notation.
    </p>
<pre>TypeDef     =  TypeMacro | TypeExpr
TypeMacro   =  <span class="literal">"("</span> TypeArg {<span class="literal">","</span> TypeArg} <span class="literal">")"</span> TypeExpr
TypeArg     =  <span class="pattern">VARIABLE</span> <span class="literal">"="</span> TypeExpr
TypeExpr    =  TypeExpr<sub>1</sub> [<span class="literal">"?"</span>]
TypeExpr<sub>1</sub>   =  TypeExpr<sub>2</sub> {<span class="literal">"|"</span> TypeExpr<sub>2</sub>}
TypeExpr<sub>2</sub>   =  TypeExpr<sub>3</sub> {<span class="literal">"+"</span> TypeExpr<sub>3</sub>}
TypeExpr<sub>3</sub>   =  TypeExpr<sub>4</sub> | <span class="pattern">VARIABLE</span> | <span class="pattern">NAME</span> [<span class="literal">"("</span> TypeExpr {<span class="literal">","</span> TypeExpr} <span class="literal">")"</span>]
TypeExpr<sub>4</sub>   =  TypeExpr<sub>5</sub> | <span class="literal">"*"</span> | <span class="literal">"integer"</span> | <span class="pattern">CHOICE</span> {<span class="literal">"_"</span> <span class="pattern">CHOICE</span>}
TypeExpr<sub>5</sub>   =  BasicType | DictType | ListType | RecordType
BasicType   =  <span class="literal">"none"</span> | <span class="literal">"boolean"</span> | <span class="literal">"number"</span> | <span class="literal">"string"</span>
DictType    =  <span class="literal">"&lt;"</span> TypeExpr <span class="literal">"&gt;"</span>
ListType    =  <span class="literal">"["</span> TypeExpr <span class="literal">"]"</span>
RecordType  =  <span class="literal">"{"</span> [Fields] <span class="literal">"}"</span>
Fields      =  Field {<span class="literal">","</span> Field}
Field       =  <span class="pattern">FIELD</span> <span class="literal">":"</span> TypeExpr MetaField
MetaField   =  {<span class="literal">"@"</span> <span class="pattern">FIELD</span> <span class="literal">"="</span> Annotation}
Annotation  =  <span class="pattern">CHOICE</span> | <span class="pattern">FIELD</span></pre>
    <p>
The token patterns are defined by the following regular expressions.
    </p>
<pre><span class="pattern">CHOICE</span>    <span class="literal">"</span>[<span class="literal">0</span>-<span class="literal">9</span><span class="literal">A</span>-<span class="literal">Z</span><span class="literal">a</span>-<span class="literal">z</span><span class="literal">.-+_$</span>]+<span class="literal">"</span>
<span class="pattern">FIELD</span>     [<span class="literal">a</span>-<span class="literal">z</span>][<span class="literal">0</span>-<span class="literal">9</span><span class="literal">A</span>-<span class="literal">Z</span><span class="literal">a</span>-<span class="literal">z</span>]*
<span class="pattern">NAME</span>      [<span class="literal">A</span>-<span class="literal">Z</span>][<span class="literal">0</span>-<span class="literal">9</span><span class="literal">A</span>-<span class="literal">Z</span><span class="literal">a</span>-<span class="literal">z</span>]+(<span class="literal">.</span>[<span class="literal">A</span>-<span class="literal">Z</span>][<span class="literal">0</span>-<span class="literal">9</span><span class="literal">A</span>-<span class="literal">Z</span><span class="literal">a</span>-<span class="literal">z</span>]+)*
<span class="pattern">VARIABLE</span>  [<span class="literal">A</span>-<span class="literal">Z</span>]</pre>
    <p>
This document employs a terse notation to bind names to type definitions. The next example defines the standard type names. Datatype <code>Any</code> matches any type, including optional ones. Datatype <code>Flag</code> is a boolean-like type, where <span class="literal">null</span> stands for false and <span class="literal">"y"</span> for true. Datatype <code>Text</code> avoids problems with newline characters. A new line of textual data is represented as an additional string in the list. The standard macros <code>List</code>, <code>Dict</code> and <code>Maybe</code> construct list, dictionary and optional types. For example, <code>Maybe(number)</code> is a more verbose way to express <code>number?</code>. When a macro is evaluated without actual arguments, the formal arguments are bound to their default types. The expression <code>List</code> is thus a shorthand for <code>[Any]</code>. Datatype <code>Record</code> describes any record value.
    </p>
<pre>Any: *?
Flag: "y"?
Text: string | [string]
List: (T=Any) [T]
Dict: (T=Any) &lt;T&gt;
Maybe: (T=*) T?
Record: {}</pre>
    <h2>Type evaluation</h2>
    <p>
It's not possible to make an optional type more optional. It is syntactically already impossible, i.e. <code>T??</code> is not a valid type expression, but the evaluation of a type expression can still run into this problem. Optionality must be an idempotent operation in a typespace.
    </p>
<pre><span class="inline rule-condition">S = T?<br/>T = U?</span><span class="inline rule-conclusion">S = U?</span></pre>
    <p>
An optional <code>none</code> type is nonsensical. An optional value is either <code class="literal">null</code> or a value of the <dfn>mandatory type</dfn>. This assumes mandatory types cannot have a <code class="literal">null</code> value. A mandatory type must match a wildcard type.
    </p>
<pre><span class="inline rule-condition">S = none?</span><span class="inline rule-conclusion">S = none</span></pre>
    <p>
Type addition <code>S</code> combines the fields of record types <code>T</code> and <code>U</code>. If a field is defined in both <code>T</code> and <code>U</code>, the field definition from <code>U</code> ends up in addition <code>S</code>. The field of <code>U</code> is said to refine the inherited field of <code>T</code>, although the refined field type is not restricted by the inherited field type.
    </p>
<pre><span class="inline rule-condition">S = T + U</span><span class="inline rule-conclusion">S = { fields from T and not in U, &hellip;, fields from U, &hellip; }</span></pre>
    <p>
A <code>none</code> alternative lifts a union type to an optional type. Union types cannot have a <code>none</code> alternative.
    </p>
<pre><span class="inline rule-condition">S = T | none</span><span class="inline rule-conclusion">S = T?</span></pre>
    <p>
An optional alternative lifts a union type to an optional type. Union types cannot have optional alternatives. Optional alternatives must be replaced by mandatory types in the lifted union type <code>S<sub>1</sub></code>.
    </p>
<pre><span class="inline rule-condition">S = T | U<br/>T = V?</span><span class="inline rule-conclusion">S<sub>1</sub> = V | U<br/>S = S<sub>1</sub>?</span></pre>
    <p>
A wildcard alternative lifts a union type to a wildcard type. Union types cannot have a wildcard alternative.
    </p>
<pre><span class="inline rule-condition">S = T | *</span><span class="inline rule-conclusion">S = *</span></pre>
    <p>
A union type flattens alternatives. Union types cannot nest union alternatives.
    </p>
<pre><span class="inline rule-condition">S = T | U<br/>T = V | W</span><span class="inline rule-conclusion">S = V | W | U</span></pre>
    <p>
A union type merges enumeration alternatives. The distinct choices of enumeration alternatives are merged in one enumeration type. At most one enumeration alternative is allowed in a union type.
    </p>
<pre><span class="inline rule-condition">S = T | "u<sub>1</sub>"_"u<sub>2</sub>" &hellip; _"u<sub>n</sub>"<br/>T = "t<sub>1</sub>"_"t<sub>2</sub>" &hellip; _"t<sub>m</sub>"</span><span class="inline rule-conclusion">S = "t<sub>1</sub>"_"t<sub>2</sub>" &hellip; _"t<sub>m</sub>"_"u<sub>1</sub>"_"u<sub>2</sub>" &hellip; _"u<sub>n</sub>"</span></pre>
    <p>
An integer alternative is obsolete, if basic type <code>number</code> is another alternative. Integers are basic numbers.
    </p>
<pre><span class="inline rule-condition">S = integer | number</span><span class="inline rule-conclusion">S = number</span></pre>
    <p>
An enumeration alternative is pointless, if basic type <code>string</code> is another alternative, because enumerations are subtypes of <code>string</code>.
    </p>
<pre><span class="inline rule-condition">S = "t<sub>1</sub>"_"t<sub>2</sub>" &hellip; _"t<sub>m</sub>" | string</span><span class="inline rule-conclusion">S = string</span></pre>
    <p>
Duplicate alternatives are superfluous. Union types cannot specify identical alternatives.
    </p>
<pre><span class="inline rule-condition">S = T | T</span><span class="inline rule-conclusion">S = T</span></pre>
    <p>
The evaluation of a recursive type expression should abort with an error message if the expression cannot be reduced to a cyclic type.
    </p>
<pre><span class="inline rule-condition">S = &hellip; S &hellip; </span><span class="inline rule-conclusion">cyclic S or evaluation error</span></pre>
    <h2>Marshal and unmarshal</h2>
    <p>
The unmarshal function of a type constructs a data value from a JSON representation. The marshal function is the inverse function from data value back to JSON representation. Marshalling a data value and unmarshalling the resulting JSON representation should produce an equal value.
    </p>
    <p>
The marshal and unmarshal function of a basic type is the identity function. The JSON representation of a basic value cannot be distinguished from the value itself. A typespace can define an alias for a basic type, but the type alias can never be the type of a basic value. The type of a basic value is 'hardcoded' in the value.
    </p>
    <p>
Integer and enumeration types marshal their values as JSON numbers and strings, although these are unmarshalled as basic values. This loss of type information is not a problem, if the construction site expects an integer or enumerated choice. Field <code>foo</code> of record type <code>Example</code> expects basic string <code class="literal">"a"</code> or <code class="literal">"b"</code>. The type information, required to validate a basic string as an enumerated choice, is inferred from the construction site.
    </p>
<pre>Example: {
  foo: "a"_"b"
}</pre>
    <p>
Dictionary, list and record types unmarshal data values from untyped and typed JSON representations. An <dfn>untyped JSON representation</dfn> suffices if the type of a value can be inferred from the construction site. A <dfn>typed JSON representation</dfn> is required to preserve the type of a value when this information cannot be inferred.
    </p>
    <p>
The untyped representation of a list value is a JSON array. The typed representation stores this array in the underscore entry of a JSON object. The list type is expressed in the dollar entry of this object. List values benefit the most from an untyped representation, because it avoids the creation of a wrapper object. The array <code class="literal">[4,2]</code> is the untyped representation of a list value with type <code>[number]</code>. The typed representation <code class="literal">{$:'[number]',_:[4,2]}</code> wraps the array in an extra object to preserve the list type.
    </p>
    <p>
The only difference between the untyped and typed JSON representation of a record value is the missing dollar entry in the untyped representation. Both representations are JSON objects. The typed representation <code class="literal">{$:'Example',foo:'b'}</code> includes the type of a record value, which is dropped from the untyped representation <code class="literal">{foo:'b'}</code>. If records have many fields, the penalty for an extra dollar entry in typed representations is negligible.
    </p>
    <p>
A record value drops a field from the JSON representation, if the field value is <code class="literal">null</code>. A new record value initializes a field to <code class="literal">null</code>, if the field is not present in the JSON representation. This optimization turns standard type <code>Flag</code> into an efficient type for boolean fields with a bias towards false. A cleared flag, i.e. the common case, is missing, but a set flag is initialized to <code class="literal">"y"</code> in the JSON representation. Record types often define <code class="literal">null</code> as the default field value to optimize JSON representations.
    </p>
    <p>
The untyped representation of a dictionary value is a JSON object with an underscore entry that contains another JSON object. The nested JSON object maps dictionary keys to values. Dictionary entries cannot be represented in the root JSON object, because this results in ambiguous representations when a dollar and/or an underscore is a dictionary key. Typed representations of dictionaries employ the same scheme as list values, i.e. a dollar expresses the type information and an underscore holds an untyped container with elements. The typed representation of an empty dictionary with numbers is <code class="literal">{$:'&lt;number&gt;',_:{}}</code>. The omission of the dollar entry in the untyped representation <code class="literal">{_:{}}</code> is similar to record values.
    </p>
    <p>
Optional and union types unmarshal data values from JSON representations, but they do not marshal values back to JSON representations, because the type of a value is either a basic, dictionary, list or record type. Optional types can unmarshal values from untyped representations. If the inferred type at a construction site is <code>Example?</code>, the untyped representation <code class="literal">{foo:'a'}</code> preserves record type <code>Example</code>. A union type can unmarshal a value from an untyped representation if there is exactly one dictionary, list or record alternative to choose from. Standard type <code>Text</code> specifies one string list alternative. If the inferred type is <code>Text</code>, the untyped representation <code class="literal">['One','Two']</code> preserves list type <code>[string]</code>.
    </p>
    <h2>Field annotations</h2>
    <p>
A record field is annotated to specify additional field characteristics. Annotations are nonessential field decorations. A field value must obey the rules of the field type, regardless what the annotations specify. It doesn't matter what the <code>@spam</code> annotation in the next example means, a value from field <code>foo</code> is always a basic number. The meaning of an annotation is defined in modules that are not part of the type system.
    </p>
<pre>Example: {
  foo: number @spam=eggs
}</pre>
    <p>
A record value exposes annotations through meta fields. A <dfn>meta field</dfn> holds a dictionary with the annotations of a field definition. The type of a meta field is predefined as <code>&lt;string&gt;</code>. The name of a meta field prefixes the original field name with an at-sign. A record of type <code>Example</code> has meta field <code>@foo</code>. The dictionary in this meta field maps <code class="literal">'spam'</code> to <code class="literal">'eggs'</code>.
    </p>
    <h2>Summary</h2>
    <p>
The open mainframe architecture preserves the type of data values when they are communicated over the network. The communication of a data value is only possible if the sender and receiver 'speak' the same type language. A typespace defines expressions and macros that can be referenced with a type name. The typespaces of the sender and receiver must be the same.
    </p>
    <h1>Delta sessions</h1>
    <p>
The delta service is the beating heart of oma. A client and server side, sharing and synchronizing a model, is a recurring theme in the architecture. Terminal, application and process sessions are delta sessions, albeit with different models and/or directions.
    </p>
    <h2>Session model</h2>
    <p>
A session model holds a root value. The <dfn>root value</dfn> is a composed value that captures the complete state of a model.  The typespace of a delta session defines type <code>Delta.Model</code> that describes the root value. This type is referenced from other types of the delta service, but the service does not define type <code>Delta.Model</code>. A delta session is an instrument to synchronize a model without regard for semantics. The client and server side have to agree what the root value in the session model actually means.
    </p>
    <p>
Record type <code>Example</code> is the type of a hypothetical root value whose meaning is unknown.
    </p>
<pre>Example: {
  foo: number,
  bar: [string],
  baz: boolean
}</pre>
    <p>
The next figure depicts a record of type <code>Example</code> as a tree structure where leaf nodes are basic values and other nodes are composed values. A composed value expresses its type inside the value node.
    </p>
    <figure>
    <span class="internal node">Example</span><br/>
    <span class="path">foo<span style="margin: auto 1em;">bar</span>baz</span><br/>
    <span>&#8601;<span style="margin: auto 2em;">&#8595;</span>&#8600;</span><br/>
    <span class="literal leaf node">42</span> <span class="internal node">[string]</span> <span class="literal leaf node">true</span><br/>
    <span class="path">1<span style="margin: auto 1em;">2</span>3</span><br/>
    <span>&#8601;<span style="margin: auto 2em;">&#8595;</span>&#8600;</span><br/>
    <span class="literal leaf node">'arthur'</span> <span class="literal leaf node">'ford'</span> <span class="literal leaf node">'zaphod'</span><br/>
    <figcaption>Root value</figcaption>
    </figure>
    <p>
A value in a session model is identified by the path list from root node to value node in the tree structure. A path element is a unique tag for an arrow from parent to child node. A path element is the name of a record field, the key of a dictionary entry or the index of a list element. Lists have one-based indices. The first element is located at index <code>1</code>, the second at <code>2</code>, etc.
    </p>
    <h3>Annotations</h3>
    <p>
Record fields are annotated to specify characteristics of record values in session models. A field without annotations is a <dfn>data field</dfn> that the server side can modify in a delta session. When the root value of a session model is a record of type <code>Example</code>, the server side can send an action in a delta response that assigns a new number to data field <code>foo</code>. The client side can only read the number in the model.
    </p>
<pre>Example: {
  foo: number
}</pre>
    <p>
An <code>@event</code> annotation specifies an <dfn>event field</dfn>. Record types ignore event fields when marshalling or unmarshalling. The annotation value is <code>client</code> or <code>server</code>. In the next example, field <code>foo</code> is a server event field. The server side reports an occurence of this event in a delta response. Field type <code>none</code> implies an occurence is unstructured. The client side is informed about an occurence, but the reported event does not provide any additional information.
    </p>
<pre>Example: {
  foo: none @event=server 
}</pre>
    <p>
A client event field is the origin of an event in a delta request. In the next example, the client informs the server side about an occurence of event field <code>foo</code> as soon as possible, which is the default client reaction to an event occurence. The field type implies an occurence conveys a boolean value.
    </p>
<pre>Example: {
  foo: boolean @event=client 
}</pre>
    <p>
A <code>@delay</code> annotation alters the client reaction to an event occurence. The annotation value is <code>block</code>, <code>flush</code> or <code>forever</code>. The client side sends a delta request with an occurence of event field <code>foo</code> in the next example as soon as possible. Unlike the default non-blocking reaction, a blocked client is not allowed to modify the session model while it awaits the delta response. The model is locked and the client has to wait for the server to process the blocking event.
    </p>
<pre>Example: {
  foo: boolean @event=client @delay=block
}</pre>
    <p>
The client side buffers an occurence of event field <code>foo</code> in the next example. The actions in this buffer are flushed and added to the request, when the client sends the next delta request.
    </p>
<pre>Example: {
  foo: boolean @event=client @delay=flush
}</pre>
    <p>
The server side is not interested in the occurence of event field <code>foo</code> in the next example. It expects the client to delay occurences indefinitely. The server can modify meta field <code>@foo</code> if it wants to be informed about occurences. Apart from the predefined type, a meta field is a regular data field of a record value, which the server side can target with delta actions.
    </p>
<pre>Example: {
  foo: boolean @event=client @delay=forever
}</pre>
    <p>
A <code>@data</code> annotation specifies a data field that is modifiable on the client side. The annotation value is <code>client</code> or <code>both</code>. In the next example, the client and server side can update data field <code>foo</code> in a session model with a new string value. When the client changes the field, the default reaction is to report the modification in a delta request as soon as possible. The default reaction is non-blocking.
    </p>
<pre>Example: {
  foo: string @data=both
}</pre>
    <p>
A <code>@delay</code> annotation specifies an alternative client reaction to a data modification. The annotation value is <code>block</code>, <code>flush</code> or <code>pause</code>. The values <code>block</code> and <code>flush</code> have the same meaning for data and event fields. In the next example, the client side buffers a modification of field <code>foo</code>. When this modification is still the most recent field modification after a small pause, the client sends a delta request as soon as possible. This gives the client some time to assign consecutive field values, while the server side is only informed about the last value.
    </p>
<pre>Example: {
  foo: string @data=both @delay=pause
}</pre>
    <p>
When the client owns a data field, the server side cannot modify the field value in a session model. Although the server conceptually owns the whole model, the server only computes the initial value of field <code>foo</code> in the next example. Once the field value is part of the model, the client side becomes the sole owner. The field annotations, contained in meta field <code>@foo</code>, remain under server control.
    </p>
<pre>Example: {
  foo: string @data=client @delay=block
}</pre>
    <h2>Session API</h2>
    <p>
Delta sessions are directories on web servers of open mainframes. The delta service hosts a number of HTTP resources for a delta session. An HTTP client accesses a session resource to initiate a session operation. Many session operations use datatypes to describe parameters and results.
    </p>
    <h3><code>POST <span class="variable">session</span>/do</code></h3>
    <p>
The most prominent session resource is <code>do</code> that performs delta actions on the model. The body of an HTTP request encodes the untyped JSON representation of a delta message. The HTTP response contains the untyped representation of the next delta message. Field <code>sequence</code> of a <code>Delta.Message</code> record is an integer that distinguishes between a delta request and response. Requests have positive, odd sequence numbers. Responses have nonnegative, even sequence numbers. A delta message is denoted as &#x03b4;(n) in this document, where n is a sequence number. The first delta request from the client side is &#x03b4;(1). The actions of response &#x03b4;(2m) reflect the effects that resulted from processing actions of request &#x03b4;(2m-1). The first delta response &#x03b4;(0) from the server side assigns the initial model of a reverse session. Field <code>lease</code> counts the number of seconds the receiver of a message has left before it should produce the next delta message. Field <code>retried</code> is set if the message was retried after a communication failure.
    </p>
<pre>Delta.Message: {
  sequence: integer,
  actions: [Delta.Action],
  lease: number,
  retried: Flag
}</pre>
    <p>
A delta action occurs in some part of the model. Field <code>path</code> locates this part in the model, starting from the root value. When a path element is a string, it selects a record field or dictionary entry for the resolution of the remaining path elements. An integer path element selects an element from a list value for the remainder of the path.
    </p>
<pre>Delta.Action: { 
  path: [string | integer]
}</pre>
    <p>
An assignment action modifies a value in the model. A signal action reports a client or server event in the model. Both assignments and signals must be properly typed. The path of an action infers what type of value can be assigned or what type of event can be signalled. For example, if the path of an assignment leads to a dictionary entry in the model, the assigned value must obey the rules of the element type.
    </p>
<pre>Delta.Assign: Delta.Action + {
  value: Any
}
Delta.Signal: Delta.Action + {
  event: Any
}</pre>
    <p>
The path of a splice action locates a position in a list value. Field <code>deletes</code> counts the number of list elements to delete at this position. The nonnegative delete count cannot exceed the number of remaining list elements at the position. Field <code>values</code> holds the values to insert at the position. Inserted values must be described by the element type. At least one element must be inserted, if the delete count is zero.
    </p>
<pre>Delta.Splice: Delta.Action + {
  deletes: integer,
  values: [Any]?
}</pre>
    <p>
A removal action specifies keys to remove from a dictionary value in the model. The keys must be present in the dictionary and at least one key must be removed.
    </p>
<pre>Delta.Remove: Delta.Action + {
  keys: [string]
}</pre>
    <p>
An update action fuses several assignments into a single action. At least one assignment is required. Field <code>assigns</code> is a dictionary whose entry keys specify the assignment locations for entry values. If the path of an update action locates a record or dictionary in the session model, the assignment keys identify record fields or dictionary entries. If a list is located at the update path, the assignment keys are string representations of integer indices. A goto action jumps to a location in the model from where one or more relative actions are performed.
    </p>
<pre>Delta.Update: Delta.Action + {
  assigns: &lt;Any&gt;
}
Delta.Goto: Delta.Action + {
  actions: [Delta.Action]
}</pre>
    <p>
Goto and update actions are optimizations that avoid path duplications to minimize the payload of delta messages.
    </p>
    <h3><code>GET <span class="variable">session</span>/poll</code></h3>
    <p>
An HTTP client polls a delta session to inspect the current session status. The HTTP response contains the untyped JSON representation of a <code>Delta.Status</code> record. The <code>poll</code> response cannot be cached. Field <code>expects</code> is the sequence number of a delta message. When even, the server side is supposed to produce the next delta response. Otherwise the client side should come up with the next delta request. Field <code>after</code> counts how many lease seconds are remaining for the producing side. A negative value means the next message is overdue. The absolute value counts how many seconds the producing side is late.
    </p>
<pre>Delta.Status: {
  expects: integer,
  after: number
}</pre>
    <p>
A forward session always expects a delta message with a positive sequence number. A reverse session can also expect an HTTP client to post the first delta response &#x03b4;(0) with an initial model.
    </p>
    <h3><code>GET <span class="variable">session</span>/dump</code></h3>
    <p>
A session dump conveys the complete state of a session. An HTTP client cannot cache the <code>dump</code> response with the untyped representation of a <code>Delta.Dump</code> record. The record combines the current status of a session with the root value.
    </p>
<pre>Delta.Dump: Delta.Status + {
  root: Delta.Model?
}</pre>
    <p>
The root value is <code class="literal">null</code>, if a reverse session is dumped, which still expects an HTTP client to assign an initial model.
    </p>
    <h3><code>GET <span class="variable">session</span>/types</code></h3>
    <p>
Both sides of a delta session parse and evaluate type definitions. A <code>types</code> response contains the untyped JSON representation of a dictionary with strings. The <code>types</code> response should be cached. A dictionary entry maps a type name to the source of a type expression or macro. The dictionary exports the typespace of a session, minus the definition of <code>Delta.Model</code>. The removal of <code>Delta.Model</code> promotes reuse of type definitions. For example, the <code>types</code> response in an application session is the same as the <code>types</code> response in a process session of the application.
    </p>
    <h3><code>GET <span class="variable">session</span>/model</code></h3>
    <p>
An HTTP client sends a <code>model</code> request to obtain the definition of datatype <code>Delta.Model</code>. The <code>model</code> response with the textual source of a type definition should be cached. A <code>model</code> response is combined with a <code>types</code> response to construct the typespace of a session.
    </p>
    <h3><code>POST <span class="variable">session</span>/ready</code></h3>
    <p>
A <code>ready</code> request is appropriate when an HTTP client has a reasonable amount of lease time left to send the next delta message. The <code>ready</code> response may take a while to arrive, but when it arrives before the lease period expires, it contains the new lease time. A zero lease time instructs the HTTP client to send the next delta message right away. A <code>ready</code> response controls the lease period without altering the sequential flow of delta messages. It is still up to the HTTP client to produce the next delta message when the lease period expires. 
    </p>
    <h3><code>POST <span class="variable">session</span>/greedy</code></h3>
    <p>
An HTTP client posts a <code>greedy</code> request when it wants to receive the next delta message as soon as possible. It must therefore be waiting for a <code>do</code> response. The <code>greedy</code> response contains the remaining lease time. If the <code>greedy</code> response contains a zero, the lease time was successfully reset, and the HTTP client should receive the next delta message shortly. If the <code>greedy</code> response contains a positive number, the lease time could not be reset. The HTTP client may have to wait for the lease period to expire before it receives the next delta message. A negative number indicates the next delta message is already overdue. 
    </p>
    <h3><code>POST <span class="variable">reverse session</span>/plumb</code></h3>
    <p>
Paired delta sessions support <dfn>binary pipes</dfn> to transfer files from the client to the server side of a session pair. The server side posts a <code>plumb</code> request to create a binary pipe. The body of a <code>plumb</code> response is a string with the name of a new pipe. Pipe creation is usually triggered by some upload event in a delta request, which describes the files the client side wants to upload, although the server side is allowed to create a binary pipe at any time. 
    </p>
    <h3><code>POST <span class="variable">forward session</span>/pipe/<span class="variable">name</span></code></h3>
    <p>
The client side of a paired session posts an HTTP request with a <code>multipart/form-data</code> body to upload files to a binary pipe. The pipe name has been communicated with some push event in a delta response, which instructs the client side to initiate the upload. The pipe name is not stored in the session model with an assignment, because pipes are transient channels.
    </p>
    <h3><code>GET <span class="variable">reverse session</span>/pipe/<span class="variable">name</span></code></h3>
    <p>
The server side of a paired session sends an HTTP request to download files from a binary pipe. The pipe name is taken from a <code>plumb</code> response. The <code>multipart/form-data</code> body of the HTTP response encodes the files. 
    </p>
    <h3><code>POST <span class="variable">forward session</span>/alloc</code></h3>
    <p>
A forward delta session can own a web directory with cached files. Unlike a binary pipe with one reader and writer, a cache has many readers and one owner that writes content. A <code>Delta.File</code> record describes a cached file. Field <code>local</code> is a suggestion for a local file name when cache readers save a cached file. The size is measured in bytes. An empty type indicates an unknown MIME type.
    </p>
<pre>Delta.File: {
  local: string?,
  size: integer,
  type: string
}</pre>
    <p>
A cache owner posts an <code>alloc</code> request, when it wants to add a file to the cache. The body of an <code>alloc</code> request encodes the untyped JSON representation of a <code>Delta.File</code>. The textual body of the <code>alloc</code> response is the name of a new cache entry. The allocated name allows the URL of a cached file to be derived before the file content has been copied to the cache. 
    </p>
    <h3><code>POST <span class="variable">forward session</span>/realloc</code></h3>
    <p>
When a cache owner needs to restore purged files in the cache, it posts a <code>realloc</code> request. The body of a <code>realloc</code> request encodes the untyped JSON representation of a dictionary that maps allocated names of cache entries to <code>Delta.File</code> records. A <code>realloc</code> response is an estimate of remaining cache space. The estimate counts the number of available gigabytes. 
    </p>
    <h3><code>PUT <span class="variable">forward session</span>/cache/<span class="variable">name</span></code></h3>
    <p>
A cache owner puts a new file in the cache. The name of the cache entry must have been newly allocated or restored after a purge. The HTTP request body contains the binary content that should be copied to the cache. The size and MIME type of the content must correspond with the allocated file info. The file remains cached until the cache entry is purged or the session of the owner is closed.
    </p>
    <h3><code>GET <span class="variable">cache directory</span>/<span class="variable">name</span></code></h3>
    <p>
A cache reader retrieves a file from the cache. The HTTP response with the file should be privately cached and revalidated on every access.
    </p>
    <p>
The directory where readers locate cached files, is not a resource in the session of the cache owner. The forward session and the cache directory may be located on different networks. For example, an application is a cache owner whose session is found in a backend network, but the directory with cached files is located in the frontend network where terminals can access the files.
    </p>
    <p>
When an HTTP client attempts to retrieve a cached file, the delta service verifies the HTTP request originates from an authentic cache reader. If not, the HTTP client is informed that the file could not be found. If the request has an authentic origin, the user must be authorized to access the cached file. Authorization is coordinated with delta events in the session model of the cache owner. The delta service generates an event that describes users accessing files. The event conveys a dictionary value that maps file names to <code>Delta.Access</code> records. Field <code>content</code> is the current status of the file in the cache. The file content is cached in the directory, the file name has been allocated but the content is not in the cache, or the file name is not known to the delta service. Field <code>guests</code> identifies the users that are attempting to get the file from the cache. 
    </p>
<pre>Delta.Access: {
  content: "cached"_"allocated"_"unknown",
  guests: [string]
}</pre>
    <p>
The cache owner signals an authorization event back that grants and revokes access to cached files. The event contains a dictionary that maps file names to <code>Delta.Authorization</code> records. Fields <code>allows</code> and <code>denies</code> specify lists of users with authorized and unauthorized access to the cached file. 
    </p>
<pre>Delta.Authorization: {
  allows: [string],
  denies: [string]
}</pre>
    <p>
The delta service can purge cache entries, but it does not maintain a history of purged names. When the delta service generates an event that describes guests accessing cached files, the event contains the status of files in the cache. The cache owner should revoke access to any unknown files it encounters, but it should restore purged files in the cache if their access is granted. The owner must ensure restored files are identical to purged files.
    </p>
    <h2>Protocol scenarios</h2>
    <p>
The following scenarios demonstrate how the delta protocol expects the client and server side of a session to behave. The direction of a delta session is irrelevant unless it is explicitly mentioned in a scenario. Otherwise, the HTTP client is either the client side of a forward session or the server side of a reverse session. Whatever the role of the HTTP client is, the web server always plays the other role in the delta session.
    </p>
    <h3>Happy days</h3>
    <p>
In the happy days scenario, the sequential exchange of delta messages proceeds without problems.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client on this side posts a <code>do</code> request with &#x03b4;(n) to the other side. The delta message has a lease time that tells the other side how long it can take to reply with &#x03b4;(n+1).
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
After processing the actions of &#x03b4;(n), the other side replies with &#x03b4;(n+1) before the lease period expires.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n+2)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
This side processes the actions of &#x03b4;(n+1). The delta message from the other side contains a deadline for this side to post &#x03b4;(n+2).
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+3)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies on time with &#x03b4;(n+3), completing another cycle of the delta protocol.
        </p>
      </li>
    </ol>
    <p>
The sequential, turn-based exchange of messages simplifies the delta protocol. At any given moment, there is one side of the session, which has to produce the next delta message that transforms the model to a new state. The lease period of the last delta message sets a deadline for the producing side, ensuring regular contact between both sides.
    </p>
    <h3>Lost delta message</h3>
    <p>
An HTTP client can communicate with a server over multiple TCP connections, which might reorder the flow of HTTP messages. Proxies between an HTTP client and server may also complicate message delivery. The delta protocol assumes the delivery of a message can fail, without receiving a notification of this communication failure before the lease period expires. 
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="bad-side">&perp;</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side, but the delta message never arrives. The client is not notified of this failure before the lease period of &#x03b4;(n) expires.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="delta-side">session</span>
        <p>
When the HTTP client does not receive the expected &#x03b4;(n+1), it polls the session on the web server to see what's going on. The <code>poll</code> request is sent when the lease period expires.
        </p>
        <p>
If the lease period of &#x03b4;(n) is fairly large, it may take a while before the client polls the session to detect problems. An HTTP client can poll the session to seek early confirmation of successful message delivery. When the <code>poll</code> response reveals the other side is expected to produce &#x03b4;(n+1), this side knows &#x03b4;(n) has been delivered.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">expects &#x03b4;(n)<br/>&larr;</span> <span class="delta-side">session</span>
        <p>
In this scenario, the <code>poll</code> response reveals the session is still expecting the HTTP client to post &#x03b4;(n).
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do retried &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
When the HTTP client knows &#x03b4;(n) hasn't arrived at the other side, it aborts the old <code>do</code> request and it posts a new &#x03b4;(n) with a set <code>retried</code> flag.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The retried &#x03b4;(n) arrives without problems. The other side replies with &#x03b4;(n+1) on time to complete another cycle of the delta protocol.
        </p>
      </li>
    </ol>
    <p>
The previous scenario showed the HTTP client on this side must be able to reproduce &#x03b4;(n) when the last attempt to post &#x03b4;(n) failed. The next scenario shows the other side has the same responsibility after replying with &#x03b4;(n+1). In general, some side of a session should hold on to its last delta message &#x03b4;(m) until it has produced &#x03b4;(m+2) in the next session cycle.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts &#x03b4;(n) to the other side, which arrives without problems.
        </p>
      </li>
      <li>
        <span class="bad-side">&perp;</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1) as expected, but this HTTP response is lost.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="delta-side">session</span>
        <p>
The HTTP client polls the session when it does not receive &#x03b4;(n+1) on time.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">expects &#x03b4;(n+2)<br/>&larr;</span> <span class="delta-side">session</span>
        <p>
The <code>poll</code> response reveals the session already expects this side to post &#x03b4;(n+2). The HTTP client knows &#x03b4;(n+1) is probably lost.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do retried &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client aborts the old <code>do</code> request and it posts a retried &#x03b4;(n). In this scenario, the HTTP client strips all actions from the retried delta message, because it knows the stripped actions have already been processed.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">retried &#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
Although the other side expects &#x03b4;(n+2), it receives a retried &#x03b4;(n). The retried &#x03b4;(n) has a zero lease time and it lacks actions. The other side replies with a retried &#x03b4;(n+1).
        </p>
      </li>
    </ol>
    <p>
These scenarios demonstrate the importance of nonintrusive polling. When the HTTP client detects a potential problem, it first polls the session to get an accurate picture of the situation before it reacts, e.g. aborting a previously posted delta message.
    </p>
    <h3>Slow delta message</h3>
    <p>
When a lease period expires, there is not necessarily a real problem. A lease period may not correspond with the actual time it takes to process a delta message.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client successfully posts &#x03b4;(n).
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="delta-side">session</span>
        <p>
The HTTP client polls the session before it receives &#x03b4;(n+1).
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">expects &#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">session</span>
        <p>
The <code>poll</code> response reveals the session expects the other side to produce &#x03b4;(n+1). The HTTP client can poll the session to seek early confirmation of message delivery. In that case, the <code>poll</code> response is a positive confirmation. In the remainder of this scenario, the client polls the session, because the lease period of &#x03b4;(n) has expired. The <code>poll</code> response also reveals &#x03b4;(n+1) is overdue.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="delta-side">session</span>
        <p>
The HTTP client does not abort the posted &#x03b4;(n) when the other side takes too long to produce &#x03b4;(n+1). Polling at regular intervals detects the possible loss of &#x03b4;(n+1).
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">expects &#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">session</span>
        <p>
Every subsequent <code>poll</code> response reveals the production of &#x03b4;(n+1) takes an increasing amount of time, because the <code>after</code> field of the session status is decreasing as time passes by.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
When the other side finally produces &#x03b4;(n+1), the HTTP client receives a response for the <code>do</code> request with &#x03b4;(n), which was posted in the first scenario step.
        </p>
      </li>
    </ol>
    <p>
The HTTP client stubbornly waits for a <code>do</code> response with &#x03b4;(n+1). Although an HTTP connection is closed after a certain period of inactivity, it's impossible to predict beforehand when this is going to happen. While repeated polling reveals &#x03b4;(n+1) is still overdue, the HTTP client does not abort the connection. 
    </p>
    <h3>Ready to produce next delta message</h3>
    <p>
The easiest way to simulate bidirectional synchronization is to specify tiny lease periods in delta messages. This gives the illusion that any side can change the model at any time. Unfortunately, it also causes a lot of superfluous delta messages, if the average client and server perform actions on the session model at a much lower frequency than they exchange delta messages. The delta protocol provides a more efficient solution with <code>ready</code> requests.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1) on time. The HTTP client has plenty of lease time left after processing the actions of &#x03b4;(n+1).
        </p>      
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">ready<br/>&rarr;</span> <span class="delta-side">session</span>
        <p>
In this scenario, the HTTP client posts a <code>ready</code> request. This side is ready and willing to produce the next delta message on demand.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">30 sec<br/>&larr;</span> <span class="delta-side">session</span>
        <p>
The <code>ready</code> response sets a new lease time for this side. The response may take some time to arrive.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">ready<br/>&rarr;</span> <span class="delta-side">session</span>
        <p>
With half a minute of lease time, the HTTP client posts another <code>ready</code> request. It is still ready to produce the next delta message.
        </p>
      </li>
    </ol>
    <p>
The HTTP client in the next scenario modifies the model.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1) on time.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">ready<br/>&rarr;</span> <span class="delta-side">session</span>
        <p>
The HTTP client posts a <code>ready</code> request.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n+2)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
Before receiving a <code>ready</code> response, the HTTP client posts &#x03b4;(n+2), because it wants to synchronize the model with the other side. The HTTP client aborts the <code>ready</code> request.
        </p>
      </li>
    </ol>
    <p>
The next scenario shows a <code>ready</code> response with a zero lease time.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1) on time.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">ready<br/>&rarr;</span> <span class="delta-side">session</span>
        <p>
The HTTP client posts a <code>ready</code> request.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">0 sec<br/>&larr;</span> <span class="delta-side">session</span>
        <p>
The <code>ready</code> response resets the lease time for this side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n+2)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client immediately posts &#x03b4;(n+2) after receiving the <code>ready</code> response. The action list in the delta message may be empty.
        </p>
      </li>
    </ol>
    <p>
In the next scenario, the <code>ready</code> request is lost, but the story is almost the same when the <code>ready</code> response is lost.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1) on time.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">ready<br/>&rarr;</span> <span class="bad-side">&perp;</span>
        <p>
The HTTP client posts a <code>ready</code> request that never arrives.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n+2)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
When the <code>ready</code> request or response fails, the lease period of &#x03b4;(n+1) inevitably expires. Upon expiration, the HTTP client aborts the <code>ready</code> request and it posts &#x03b4;(n+2) to the other side.
        </p>
      </li>
    </ol>
    <p>
The last scenario explains why <code>ready</code> messages are optional. The lease period of a delta message is a safe fallback when <code>ready</code> messages are not used or fail to operate.
    </p>
    <h3>Greedy to receive next delta message</h3>
    <p>
A <code>ready</code> request is a form of courtesy, giving the session an opportunity to overrule the lease period of this side. A <code>greedy</code> request is the exact opposite. An HTTP client posts a <code>greedy</code> request in an attempt to reset the remaining lease period of the other side. 
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts &#x03b4;(n) to the other side. The lease period of &#x03b4;(n) is large. The other side will have the turn to synchronize the model for quite a while.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">greedy<br/>&rarr;</span> <span class="delta-side">session</span>
        <p>
The HTTP client posts a <code>greedy</code> request.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">26 sec<br/>&larr;</span> <span class="delta-side">session</span>
        <p>
The <code>greedy</code> response from the other side is bad news. A greedy HTTP client wants to synchronize the model, but this <code>greedy</code> response means it may take some time before this side gets a turn at synchronizing.
        </p>
      </li>
    </ol>
    <p>
In the next scenario, the <code>greedy</code> request is satisfied before the <code>greedy</code> response arrives.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">greedy<br/>&rarr;</span> <span class="delta-side">session</span>
        <p>
The HTTP client posts a <code>greedy</code> request.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1). The HTTP client aborts the <code>greedy</code> request.
        </p>
      </li>
    </ol>
    <p>
A zero <code>greedy</code> response implies satisfaction is near.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">greedy<br/>&rarr;</span> <span class="delta-side">session</span>
        <p>
The HTTP client posts a <code>greedy</code> request.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">0 sec<br/>&larr;</span> <span class="delta-side">session</span>
        <p>
The <code>greedy</code> response is zero. The lease period of the other side has been reset.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1). If it doesn't arrive as promised, the HTTP client polls the session to detect a slow or lost delta message.
        </p>
      </li>
    </ol>
    <p>
The <code>greedy</code> response is lost in the next scenario.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">greedy<br/>&rarr;</span> <span class="delta-side">session</span>
        <p>
The HTTP client posts a <code>greedy</code> request.
        </p>
      </li>
      <li>
        <span class="bad-side">&perp;</span> <span class="delta-message">13 sec<br/>&larr;</span> <span class="delta-side">session</span>
        <p>
The <code>greedy</code> response is lost.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="delta-side">session</span>
        <p>
When the lease period of &#x03b4;(n) expires, the HTTP client polls the session. It also aborts the <code>greedy</code> request that probably failed. At this point, it doesn't matter whether the <code>greedy</code> request or response failed.
        </p>
      </li>
    </ol>
    <p>
A <code>greedy</code> request from one side of a session pair generates a zero <code>ready</code> response for the other side, if the other side has posted a <code>ready</code> request. In that case, the <code>greedy</code> response is also zero. Otherwise the <code>greedy</code> response contains the remaing lease time that the other side has left.
    </p>
    <h3>Pipe files</h3>
    <p>
A binary pipe coordinates the transfer of files with delta events in a paired session.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(2n+1)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The client side of a paired session posts &#x03b4;(2n+1) to the server side. The delta request contains an upload event with information about files the client wants to upload.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(2n+2)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The server side replies with &#x03b4;(2n+2). The delta response contains a push event with the name of a binary pipe and the names of files to upload in the pipe.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">pipe/aI6Gr<br/>&rarr;</span> <span class="delta-side">session</span>
        <p>
The client posts an HTTP request to the pipe that was named in the push event. The body of the request encodes the uploaded files.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(2n+3)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
While uploading files, the client posts &#x03b4;(2n+3). Except for the loss in bandwidth, the exchange of delta messages is not affected by pipe activity.
        </p>
      </li>
    </ol>
    <p>
In the next scenario, the sides are reversed. This side is the downloading server and the other side is the uploading client in a session pair.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(2n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The server side posts &#x03b4;(2n) to the client side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(2n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The client side replies with &#x03b4;(2n+1). The delta request contains an upload event with file information.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">plumb<br/>&rarr;</span> <span class="delta-side">session</span>
        <p>
In this scenario, the server side agrees the files should be uploaded. It posts a <code>plumb</code> request to create a binary pipe for the file tranfer. 
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">aI6Gr<br/>&larr;</span> <span class="delta-side">session</span>
        <p>
The <code>plumb</code> response contains the name of a new pipe.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(2n+2)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The server side posts &#x03b4;(2n+2) whose push event informs the client side about the files to upload in the pipe.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">pipe/aI6Gr<br/>&rarr;</span> <span class="delta-side">session</span>
        <p>
The server side sends an HTTP request to download files from the pipe.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(2n+3)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
While downloading files, the server side receives &#x03b4;(2n+3) from the client side.
        </p>
      </li>
    </ol>
    <p>
A binary pipe transfers files from the client to the server side of a paired delta session. The coordination with an upload and push event prepares the downloading server for the uploading client. The coordination causes a delay, because an extra roundtrip is required to communicate a pipe name before the client kicks off the actual upload. This delay should hardly be noticeable, unless the client and server transfer many small files through separate pipes.
    </p>
    <h3>Cache files</h3>
    <p>
A cache coordinates access to files with delta events in the forward session of the cache owner. The coordination is not visible to readers that download cached files. An HTTP client simply sends a request to get a file from the cache directory, regardless whether the file is cached or not.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">alloc<br/>&rarr;</span> <span class="delta-side">session</span>
        <p>
The client side posts an <code>alloc</code> request to allocate a unique name in the cache.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">pK0vR<br/>&larr;</span> <span class="delta-side">session</span>
        <p>
The <code>alloc</code> response reveals the name of a new file in the cache. This side can now derive the URL of the cached file.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(2n+1)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
This side posts &#x03b4;(2n+1) to the server side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(2n+2)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The server side replies with &#x03b4;(2n+2). The delta response contains a download event, which specifies a user attempting to access the cached file that was allocated earlier.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(2n+3)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The client side verifies the user is authorized to access the file. It posts &#x03b4;(2n+3) to the server side with an authorization event that grants access.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">cache/pK0vR<br/>&rarr;</span> <span class="delta-side">session</span>
        <p>
After the cache owner has granted access to the file, it must put the file content in the cache.
        </p>
      </li>
    </ol>
    <p>
The cache fills up on demand. The content of a cached file must be copied when a cache reader is granted access to download an allocated file, although the content is not yet in the cache. If the content is already cached, the cache owner still authorizes a download attempt, but it should not copy the content again. If the owner revokes access, the file download fails with a status code that indicates the file could not be found. An HTTP client cannot differentiate between a file that is not cached, and a cached file that the client is not authorized to access.
    </p>
    <p>
In the next scenario, the cache owner restores a purged file.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(2n+1)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The client side posts &#x03b4;(2n+1) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(2n+2)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The server side replies with &#x03b4;(2n+2). A download event in the delta response specifies a user attempting to access content at unknown cache entry <code>pK0vR</code>, which is neither cached nor allocated.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">realloc<br/>&rarr;</span> <span class="delta-side">session</span>
        <p>
The cache owner knows the name of the cache entry belongs to a file that the delta service has apparently purged. After verifying the guest is allowed to access the file, this side posts a <code>realloc</code> request to map the name to the cached file.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">5.4<br/>&larr;</span> <span class="delta-side">session</span>
        <p>
The <code>realloc</code> response confirms the mapping of the name has been restored. With the new cache entry, the cache still has room for approximately 5.4 GB of files.  
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(2n+3)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
This side posts &#x03b4;(2n+3) to the server side with an authorization event that grants the guest access to the restored entry <code>pK0vR</code>.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">cache/pK0vR<br/>&rarr;</span> <span class="delta-side">session</span>
        <p>
After granting access to the file, the cache owner must put the file content back in the cache.
        </p>
      </li>
    </ol>
    <h3>Close session</h3>
    <p>
Delta sessions do not live forever. The next scenario shows how a session is closed.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client on this side posts &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1) on time.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(-2)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
This side decides to close the session. The HTTP client posts &#x03b4;(-2) to tell the other side the session should be closed. The delta message does not contain actions and it defines a zero lease time.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(-1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(-1) to acknowledge the session has been closed. This delta message also lacks actions.
        </p>
      </li>
    </ol>
    <p>
In the next scenario, the other side unexpectedly closes the session.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client on this side posts &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1).
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n+2)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts &#x03b4;(n+2) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(-1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(-1) to inform the session has been closed.
        </p>
      </li>
    </ol>
    <p>
A closed session does not leave any traces. All attempts to access a session resource will fail after the session has been closed.
    </p>
    <h3>Dead session</h3>
    <p>
In the previous scenarios, a session is polled to determine how a problem might be fixed. A polling operation can of course also fail, demonstrated by the session in the next scenario.
    </p>
    <ol>
      <li>
      <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="bad-side">&perp;</span>
      <p>
The HTTP client sends a <code>poll</code> request, but it does not receive a suitable response. It does not matter whether the client does not receive a <code>poll</code> response at all, or whether the <code>poll</code> response reports an HTTP failure.
      </p>
      </li>
      <li>
      <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="bad-side">&perp;</span>
      <p>
After waiting for at least three seconds, the HTTP client polls the session again. If it is still expecting a <code>poll</code> response from the previous attempt at this point, the unresponsive <code>poll</code> request is aborted.
      </p>
      </li>
      <li>
      <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="bad-side">&perp;</span>
      <p>
After another three seconds, the HTTP client polls the session for the last time. In this case, the situation remains bleak.
      </p>
      </li>
    </ol>
    <p>
If a session is unresponsive after three poll attempts, this side can safely conclude the session is dead. The delta protocol does not specify how the HTTP client should react to a dead session. It's possible the client decides to die with the session. This kind of escalation behavior is outside the scope of the protocol.
    </p>
    <h2>Standard model</h2>
    <p>
Record type <code>Delta.Standard</code> describes a standard session model. The models of application, process and terminal sessions are standard.
    </p>
    <p>
Field <code>serverLease</code> controls the amount of lease time the server side gets from the client side in the next synchronization cycle. The server side overrules the client reaction to mutations and events with field <code>maximumDelay</code>. If the field is <code class="literal">null</code>, the client respects <code>@delay</code> annotations of record fields. The value <code class="literal">'pause'</code> prevents the client from buffering actions for too long. All mutations and events are reported within a short pause. The value <code class="literal">'flush'</code> instructs the client to buffer and to flush all actions, including events with an infinite delay. Field <code>impatience</code> controls the use of <code>ready</code> and <code>greedy</code> messages in the session. If the field contains a number, an HTTP client should send a <code>ready</code> or <code>greedy</code> request if expiration of the current lease period is not expected within the specified number of seconds. If <code>plumbing</code> is set, the session can transfer files through pipes. The session owns a cache with files if <code>caching</code> is set. A cache owner receives server events from field <code>download</code> when users access cached files. Client events from field <code>approve</code> grant and deny access to cached files.
    </p>
<pre>Delta.Standard: {
  serverLease: number,
  maximumDelay: Maybe("pause"_"flush"),
  impatience: number?,
  plumbing: Flag,
  caching: Flag,
  download: &lt;Delta.Access&gt; @event=server,
  approve: &lt;Delta.Authorization&gt; @event=client
}</pre>
    <h2>Summary</h2>
    <p>
A delta session is a generic instrument to synchronize a typed model that the client and server side share. The root value of a model is a tree structure, which is targeted by delta actions from both sides of the session. Pipes and caches coordinate the transfer of files with events in session models. The binary contents of files are not stored in models.
    </p>
    <p>
Each turn has a finite lease period in the turn-based delta protocol. At any given moment, there is one side that has the turn to update the session model. Initial lease times are communicated in delta messages. The remaing lease period is optionally controlled with <code>ready</code> and <code>greedy</code> messages. When the lease period expires, the side that currently has the turn, produces the next delta message, thereby giving the turn to the other side.
    </p>
    <h1>Library bundles and archives</h1>
    <p>
The library service publishes assets of modules in bundles. The source assets of modules are preserved in library archives.
    </p>
    <h2>Module</h2>
    <p>
Modules are the common denominator of bundles and archives. A modular organization of assets is a must, because applications often require an enormous amount of assets. A module is a cohesive set of assets with a clear purpose. A module enables assets to evolve as independently as possible. A module should maximize the local impact of changes and minimize the global impact on other modules. In more pragmatic terms, a module isolates assets that are likely to be touched by a single development task. For example, assets that style the appearance of virtual widgets in an application, should be isolated from assets that implement the manifestation of virtual widgets in the DOM of a browser. Developing the appearance of an application and developing browser widgets in JavaScript are completely different tasks.
    </p>
    <p>
A module name is a fully qualified name from the <dfn>logical namespace</dfn>, e.g. <code>My.Example</code>. This is the same namespace where JavaScript classes live. JavaScript is the preferred language for structured textual assets, because web browsers can easily process JavaScript sources. The library service can furthermore minify these textual assets and merge them into one file, which improves download times of assets.
    </p>
    <h3>Configuration</h3>
    <p>
The source assets of a module are organized in a tree. The module is configured with the file <code>config.js</code> in the root directory of the source tree. The file defines a JavaScript closure, usually called <code>configure</code>, that expects one argument. The following example configures a module.
    </p>
<pre><span class="keyword">function</span> configure(module) {
  <span class="reserved">"use strict"</span>;
  module.description = <span class="literal">'The description documents the purpose of this module.'</span>;
  module.depends = [<span class="literal">'An.Other.Module'</span>];
  module.requires = {
    awesome: <span class="literal">'An.Awesome.Service'</span>
  };
  module.test = <span class="keyword">function</span> (required) {
    <span class="keyword">return</span> <span class="keyword">typeof</span> CoolFeature != <span class="literal">'undefined'</span> &amp;&amp; required.awesome.testIt();
  };
  module.provides = {
    <span class="literal">'My.Own.Service'</span>: <span class="keyword">function</span> (serviceClass, required) {
      <span class="keyword">var</span> arg = required.awesome.computeIt(<span class="literal">'bla'</span>, <span class="literal">true</span>);
      <span class="keyword">return</span> serviceClass.create(arg, <span class="keyword">this</span>.getConfig().description);
    }
  };
  module.datatype = {
    Example: <span class="literal">'Dict(integer)'</span>
  };
}</pre>
    <p>
A configuration script runs in a vanilla JavaScript environment. The order in which configuration scripts of modules are executed is undefined. The following configuration properties are common to all modules.
    </p>
    <ul>
      <li>
        <pre>description</pre>
        <p>
A description is optional, but it should be treated as a mandatory property. A concise description helps to discover and to clarify the purpose of a module. If one sentence is not sufficient, this may indicate a module has too many responsibilities.
        </p>
      </li>
      <li>
        <pre>depends</pre>
        <p>
A module configures its <dfn>explicit dependencies</dfn> on other modules. The list contains names of modules that must be loaded before the configured module can be loaded. The <dfn>implicit dependencies</dfn> of a module are ancestor modules. Module <code>My.Example.Child</code> has an implicit dependency on parent module <code>My.Example</code>.
        </p>
        <p>
Cyclic dependencies are not allowed. The type of a dependency in a cycle is irrelevant. A cycle with an explicit and implicit dependency is still a cycle.
        </p>
      </li>
      <li>
        <pre>requires</pre>
        <p>
A module configures the service providers it requires before it can be loaded. A <dfn>service</dfn> is a JavaScript class that describes the required behavior. A <dfn>provider</dfn> is a JavaScript object that implements the service behavior.
        </p>
        <p>
The configured keys identify injected service providers. The configured values are class names of services. A service provider creates a <dfn>runtime dependency</dfn> between modules. The configured module depends on other modules to implement the required services, but it does not directly specify these modules. Runtime dependencies are easier to keep up to date than explicit dependencies, because the implementation of a service provider can move from one module to another.
        </p>
      </li>
      <li>
        <pre>test</pre>
        <p>
A module might not be able to load, because it depends on nonstandard features. A module configures a closure that tests whether the module should be loaded by the runtime system. The closure is called with injected service providers. The module will only be loaded if the closure does not return <code class="literal">false</code>.
        </p>
      </li>
      <li>
        <pre>provides</pre>
        <p>
A module configures the service providers it implements for other modules. The configured keys are class names. The configured values are closures that create providers. A closure is called with two parameters. The first parameter is the class that was resolved from the configured key. The second parameter contains injected service providers. The JavaScript <code>this</code> object is bound to the module when the closure executes. The runtime system registers the service provider that the closure returns.
        </p>
      </li>
      <li>
        <pre>datatype</pre>
        <p>
Modules define JSON datatypes. The runtime system adds the type definitions to the default typespace, when it loads the module.
        </p>
      </li>
    </ul>
    <p>
The configuration of a module can span multiple files. The <code>cfg</code> directory in the root of a source tree contains additional configuration scripts. These scripts execute after the <code>config.js</code> script in the root directory, but their relative execution order is undefined.
    </p>
    <h3>Class script</h3>
    <p>
Class scripts are located under the <code>cls</code> directory in the root of a source tree. The organization of class scripts follows the Java convention where each file corresponds with a class and each directory corresponds with a namespace. The script <code>cls/My/Domain/Foo.js</code> defines JavaScript class <code>Foo</code> in namespace <code>My.Domain</code>. In the next example, a class script defines an explicit dependency on another module and it requires the injection of a service provider. The dependencies and requirements of a module are scattered over many class scripts. To determine whether a module can be loaded, the runtime system combines all dependencies and requirements from class scripts with the ones from the module configuration.
    </p>
<pre><span class="literal">'Yet.Another.Base'</span>.subclass([<span class="literal">'Yet.Another.Module'</span>], {
  $provider: <span class="literal">'Yet.Another.Service'</span>
}, <span class="keyword">function</span> (I) {
  <span class="reserved">"use strict"</span>;
  I.have(&hellip;);
  I.know(&hellip;);
})</pre>
    <p>
Class scripts specify their module dependencies and service requirements close to where these dependencies and requirements are used. This avoids maintenance problems, because it's difficult to keep a central location, i.e. one configuration script for all dependencies and requirements, in sync with class scripts.
    </p>
    <h3>Public asset</h3>
    <p>
Directory <code>pub</code> in the root of a source tree contains public assets that should be published verbatim in a bundle. A public asset is identified with an asset URL that specifies a module name and the path to a binary or textual asset. Public assets should always be referenced with asset URLs, e.g. <code>~My.Example/foo.mp3</code> for an audio sample. Asset URLs add a necessary indirection to the published contents of assets. This ensures independence from the bundle where the assets of a module have been published. When the content of a public asset is needed, the asset URL is translated to the URL of a published asset inside a bundle. The automatic translation of asset URLs is controlled with application images, which are explained elsewhere.
    </p>
    <h3>Child modules</h3>
    <p>
Directory <code>sub</code> in the root of a source tree contains directories for child modules. The name of a child module is derived from the name of the parent module and the directory name. If the source tree of module <code>My.Example</code> contains directory <code>sub/Child</code>, this directory holds the source tree of module <code>My.Example.Child</code>. Child modules are not confined to the parent's source tree. The source trees can also be kept separate, which weakens the bond between child and parent module. Unlike nested source trees, separate trees allow the child and parent module to be part of different archives and to use different version control systems for source assets.
    </p>
    <h3>Boot script</h3>
    <p>
The file <code>boot.js</code> in the root of a source tree is a boot script that implements a bundle loader. The next example shows the general structure of a boot script. The script defines a closure that expects the name of the bundle being loaded (<code>bundleId</code>) and the name of the module where the boot script is located (<code>bootName</code>). The boot script must return an object with a <code>bundle</code> method. The method receives an object whose keys are names of bundled modules and whose values are module specifications (<code>moduleSpecs_</code>). The method makes sure the specified modules get loaded.
    </p>
<pre><span class="keyword">function</span> boot(bundleId, bootName) {
  <span class="reserved">"use strict"</span>;
  &hellip;
  <span class="keyword">return</span> {
    bundle: <span class="keyword">function</span> (moduleSpecs_) {
      &hellip;
    }
  };
}</pre>
    <p>
Boot scripts are mentioned here for completeness. Their usage is discouraged, because they violate an important principle. A module with a boot script is not independent from the bundle in which the module is distributed. A bundle cannot publish modules, if two or more of these modules come with boot scripts. The reference implementation of oma only uses a boot script for bundle <code>oma-runtime</code> that initializes a JavaScript runtime environment in a booting terminal, which is capable of loading more bundles. The runtime environment conveys this capability with string method <code>bundle</code>. For example, <code>'my-app'.bundle(&hellip;)</code> instructs the runtime environment to load the specified modules of bundle <code>my-app</code>. The loader of a bundle without a boot script invokes the string method to load modules.
    </p>
    <h2>Archive</h2>
    <p>
The source assets of a module are preserved in a library archive. An archive is a zipfile that flattens source trees of modules. The root directory of the archive contains directories with module names. Each directory contains the separate source tree of the corresponding module.
    </p>
    <p>
An archive is constructed from source directories on the file system. These directories are scanned for subdirectories that contain source trees of modules. A subdirectory with a valid module name holds a source tree if the subdirectory contains file <code>config.js</code>. If the source tree of a child module is part of the parent's tree on the file system, the source tree of the child moves to the root directory of the flat archive.
    </p>
    <p>
A library archive may include generated assets. <a href="http://coffeescript.org/">CoffeeScript</a> is a popular alternative for JavaScript. If an archive contains CoffeeScript sources, it also includes the generated JavaScript sources. When a bundle publishes modules from the archive, it processes JavaScript sources, but it ignores CoffeeScript sources.
    </p>
    <h3>Bundle configurations</h3>
    <p>
A bundle selects modules from archives. The selection is configured in a JavaScript asset. The next example configures a bundle.
    </p>
<pre><span class="keyword">function</span> configure(bundle) {
  <span class="reserved">"use strict"</span>;
  bundle.description = <span class="literal">'A concise description of this bundle.'</span>;
  bundle.archives = {
    <span class="literal">'my-ui-toolkit'</span>: <span class="literal">'3.2.x'</span>,
    <span class="literal">'other-ui-toolkit'</span>: <span class="literal">'2.7.x'</span>
  };
  bundle.includes = [<span class="literal">'My.UI'</span>, <span class="literal">'Other.UI'</span>];
}</pre>
    <p>
Bundle configurations are located in directory <code>bundle</code>, below the root directory of an archive. When the subdirectories of a source directory are scanned for source trees of modules, the archiver also checks the existence of JavaScript files in subdirectory <code>bundle</code>. If the name of such a JavaScript file is a valid bundle name,
    </p>
    <h3>Launch configurations</h3>
  </body>
</html>
