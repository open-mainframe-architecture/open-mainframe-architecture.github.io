<!DOCTYPE html>
<html>
  <head>
    <title>The open mainframe architecture</title>
    <style>
html {
  font-family: serif;
  font-size: 16px;
}
body {
  counter-reset: chapter;
  padding: 10px 2%;
}
h1 {
  counter-reset: section;
}
h2 {
  counter-reset: subsection;
}
h1::before {
  counter-increment: chapter;
  content: counter(chapter) ". ";
}
h2::before {
  counter-increment: section;
  content: counter(chapter) "." counter(section) " ";
}
h3::before {
  counter-increment: subsection;
  content: counter(chapter) "." counter(section) "." counter(subsection) " ";
}
code {
  white-space: pre;
}
p {
  margin: 0.25em 0;
}
pre {
  margin-left: 0.5em;
  font-size: 80%;
}
.inline {
  display: inline-block;
}
.comment {
  color: green;
  font-style: italic;
}
.pattern {
  font-style: italic;
}
.variable {
  font-style: italic;
}
.variable::before {
  content: "\00AB";
}
.variable::after {
  content: "\00BB";
}
.figure {
  padding: 1em;
  text-align: center;
}
.keyword {
  color: blue;
}
.literal {
  color: brown;
  white-space: pre;
}
.boundary {
  border-style: dashed;
  border-width: 0;
  text-align: right;
}
.boundary span {
  font-style: italic;
  margin-right: -4em;
}
.backend {
  border-bottom-width: thin;
}
.frontend {
  border-top-width: thin;
}
.http {
  border: solid thin;
  box-shadow: 5px 5px 4px #666;
}
.http sub {
  font-size: 60%;
}
.client {
  border-radius: 10px;
  padding: 4px;
  display: inline-block;
}
.server {
  padding: 12px;
  display: inline-block;
}
.entity-isolated {
  margin: 0 1em;
}
.entity-middle {
  margin: 0 0.25em;
}
.entity-right {
  margin: 0 1em 0 0.25em;
}
.entity-left {
  margin: 0 0.25em 0 1em;
}
.network-stack {
  box-sizing: border-box;
  border-spacing: 0;
  border-collapse: collapse;
  margin: 1em auto;
  width: 20em;
}
.network-stack td {
  text-align: center;
}
.layer td {
  padding: 0.25em;
  border-width: thin 0;
}
.firewall.layer td {
  border-style: solid;
  border-width: thin;
  background-color: #f0f0f0;
  font-style: italic;
}
.network.layer td {
  border-style: solid;
}
.network-flow {
  font-size: 0.5em;
}
.layer td.network-separator {
  border-bottom-style: none;
  border-top-style: none;
  background-color: inherit;
}
.rule-conclusion, .rule-condition {
  display: inline-block;
}
.rule-condition {
  margin-left: 0.5em;
  margin-right: 2em;
}
.rule-condition:after {
  content: '\21d2';
  display: inline-block;
  margin-left: 2em;
}
.delta-side, .delta-message, .bad-side {
  display: inline-block;
  text-align: center;
}
.delta-side, .bad-side {
  width: 3em;
}
.delta-side {
  border: solid thin;
  box-shadow: 2px 2px 3px #666;
  padding: 0.25em 0;
}
.delta-message {
  line-height: 90%;
  margin: 0 1em;
  vertical-align: middle;
  width: 6em;
}
    </style>      
  </head>
  <body>
    <h1>Introduction</h1>
    <p>
The open mainframe architecture (oma) is an application architecture that revives old ideas. A terminal presents the user interface of a remote process. A mainframe traditionally runs processes for terminals, but in oma, processes run autonomously in the backend tier. A process is a running instance of a backend application that has been deployed on an open mainframe. When a terminal in the frontend starts a deployed application, the application creates a new backend process. The terminal presents the user interface of this process and it informs the process about user interactions. An open mainframe in the middle acts as a router between the frontend and backend tier.
    </p>
    <div class="figure">
      <div class="inline">
        <div class="inline entity-isolated">
          <span class="http client">term<sub>1</sub></span><br/>
          &dArr;<br/>
        </div>
        <div class="inline entity-isolated">
          <span class="http client">term<sub>2</sub></span><br/>
          &dArr;<br/>
        </div>
        <div class="inline entity-isolated">
          <span class="http client">term<sub>3</sub></span><br/>
          &dArr;<br/>
        </div>
        <div class="boundary frontend"><span>frontend boundary</span></div>
        <span class="inline http server">open<br/>mainframe</span><br/>
        <div class="boundary backend"><span>backend boundary</span></div>
        <div class="inline entity-left">
          &dArr;<br/>
          <span class="http client">proc<sub>1.1</sub></span><br/>
        </div>
        <div class="inline entity-middle">
          &uArr;<br/>
          <span class="http client">app<sub>1</sub></span><br/>
        </div>
        <div class="inline entity-right">
          &dArr;<br/>
          <span class="http client">proc<sub>1.2</sub></span><br/>
        </div>
        <div class="inline entity-left">
          &uArr;<br/>
          <span class="http client">app<sub>2</sub></span><br/>
        </div>
        <div class="inline entity-right">
          &dArr;<br/>
          <span class="http client">proc<sub>2.1</sub></span><br/>
        </div>
        <div class="inline entity-isolated">
          &uArr;<br/>
          <span class="http client">app<sub>3</sub></span><br/>
        </div>
      </div>
    </div>
    <p>
Backend applications and their processes are not concerned with user-interface technologies. Frontend terminals don't care about application logic to process user interactions. Traditional and open mainframes provide the same separation of presentation and application concerns. The open mainframe architecture inserts an extra router to improve scalability, but this does not affect the primary separation of concerns.
    </p>
    <p>
Unlike traditional mainframes with proprietary technologies, oma relies on open standards. A frontend terminal is a modern HTML browser that presents the user interface of a backend process. This process is an HTTP client that updates the user interface when the terminal reports user interactions. A backend application is an HTTP client that creates processes and manages the deployment on an open mainframe.
    </p>
    <p>
An open mainframe implements the following web services for HTTP clients on frontend and backend networks.
    </p>
    <ul>
      <li>
        <p>
delta service
        </p>
        <p>
This service creates delta sessions. The arrows in the figure are delta sessions. A <dfn>delta session</dfn> synchronizes a JSON model that both sides of the session share. The client side sends a delta request with actions on the model. A delta action is either a mutation that modifies the model, or an event that signals an incident in the model. The server side replies with a delta response whose actions on the model reflect the side effects of processing the previous request. The sequential exchange of delta messages continues, until one of the sides closes the session.
        </p>
        <p>
The direction of an arrow depicts the flow of delta requests in a delta session. Terminal and application sessions are <dfn>forward sessions</dfn>. Terminals and applications are HTTP clients that fulfil the client role in delta sessions. Processes are also HTTP clients, but they play the server role in delta sessions. Process sessions are <dfn>reverse sessions</dfn>.
        </p>
      </li>
      <li>
        <p>
welcome service
        </p>
        <p>
The welcome service establishes contact between a terminal and an open mainframe. When a user navigates a web browser to a <dfn>welcome URL</dfn>, the browser becomes a terminal that requests the welcome service to start an application. The service examines the welcome request to determine the deployed application that the user intends to start. This application is instructed to create a new process, which computes the initial model of a <dfn>virtual user interface</dfn>. The terminal presents a real version of this user interface in the web browser.
        </p>
        <p>
A reverse process session is paired with a forward terminal session. A <dfn>session pair</dfn> synchronizes the same model in opposite directions. The terminal session controls the client side of a virtual user interface and the process session controls the server side. The open mainframe relays delta messages between the client and server side of a session pair.
        </p>
      </li>
      <li>
        <p>
deploy service
        </p>
        <p>
This service deploys backend applications on an open mainframe. An HTTP client posts a request to the service with a description of the application to deploy. This description is consulted when the mainframe welcomes a terminal.
        </p>
        <p>
The service supports two forms of deployment. The deploy request of a <dfn>light deployment</dfn> consists of a JSON object that describes a backend application. The deploy request of a <dfn>heavy deployment</dfn> uploads a source archive that accompanies a JSON description. The assets in the archive are compiled and published in a directory on a web server. Both forms of deployment eventually result in a new application session. This session is used to instruct the backend application to create new processes, when terminals start the application.
        </p>
      </li>
      <li>
        <p>
library service
        </p>
        <p>
This service resembles a public library where anyone can read books, known as bundles in oma terminology. A <dfn>bundle</dfn> publishes the compiled assets of a source archive in a directory on a web server. Bundles are distribution units for modules. When a terminal needs a module from a bundle, it loads all modules of the bundle in one download. A booting terminal loads modules from standard library bundles that initialize a JavaScript runtime environment in the browser.
        </p>
        <p>
If a bundle is like a book, a module is like a chapter in a book. A <dfn>module</dfn> is a logically cohesive set of assets with a clear purpose. A modular organization reduces complexity of asset management. Developers should generally not care about the bundles in which their modules are distributed. This flexibility promotes the development of many small modules that specify their dependencies on other modules.
        </p>
      </li>
      <li>
        <p>
diagnostics service
        </p>
        <p>
Components in a perfect architecture are black boxes with hidden implementations, but the diagnostics service in oma offers a peek inside to expose some inner workings. This service supplies metrics about the performance and load of an open mainframe, e.g. number of connected terminals, deployed applications and exchanged delta messages. This operational data allows HTTP clients to monitor the health of a mainframe. Diagnostics clients should detect minor issues before they turn into major problems.
        </p>
      </li>
    </ul>
    <p>
The open mainframe architecture leverages the success of HTTP. Common problems like HTTPS encryption, serving static files and load balancing have already been solved in numerous hardware and software products. The challenge is to encorporate these products in the infrastructure of oma as smoothly as possible. Reliance on HTTP for all communication between tiers ensures HTTP-based products work equally well in frontend and backend networks.
    </p>
    <p>
Browsers are converging towards an impressive set of HTML5 standards, which cover a wide range of devices, from mobile smartphones to desktop computers. Backend applications are able to optimize the user experience for different types of devices, because every backend process handles user interactions for a particular terminal device. The open mainframe architecture does not unify terminal devices. It is up to developers to exploit device capabilities in virtual user interfaces. 
    </p>
    <p>
Despite a problematic childhood, JavaScript has matured well, demonstrated by successful products like <code>Node.js</code>. Every incarnation of oma ships with a reference implementation in JavaScript. The sole purpose of this reference implementation is to provide an executable prototype of the architecture. JavaScript is the obvious choice for a reference implementation, because terminals are web browsers that must be programmed in JavaScript. There is no compelling reason to complicate the reference implementation with another programming language. However, the success of oma depends on the availability of alternative component implementations, in as many programming language as possible. The architecture merely aims to define how components communicate over HTTP. The choice of the most suitable implementation language for an application, a process or an open mainframe is outside the scope of oma.
    </p>
    <p>
The remainder of this chapter explains the philosophy of oma in more detail. The next five chapters describe the web services of oma. Other chapters discuss architectural features that cross service boundaries.
    </p>
    <h2>Application management and user experience</h2>
    <p>
In the beginning, a mainframe was a mysterious machine in large banks and insurance companies. Terminals were primitive devices, e.g. teletypewriters, which offered a poor user experience. Monochrome monitors with keyboards improved the experience, although a happy user was never an important design goal. Users were employees that accepted how an application worked, no matter how stupid it may have been. Unhappy users are unlikely to complain when their jobs are at stake.
    </p>
    <p>
Personal computing fundamentally changed the IT industry. The PC offered a rich user experience at an affordable price. New technologies, e.g. the mouse, paved the way for advanced graphical user interfaces. The competitive PC market forced companies to innovate. Unhappy customers are likely to switch to a competitor when they feel they wasted money on an inferior product.
    </p>
    <p>
It's easy to manage applications on a mainframe, but application management is a nightmare on a network with PCs, because every PC is equipped with its own operating system and application versions. The desire of an organization to centralize application management collides with the personal freedom to install software. It's impossible to have both. An organization is likely to run into situations where the complexity of application management on a network with PCs has a negative impact on the user experience, e.g. incompatibilities between versions.
    </p>
    <p>
Web applications are a compromise. A web browser, installed on every personal device, displays HTML pages of a web application. A user is free to install other software on the device. An organization maintains the current version of the application on a web server. The first web applications were restricted to simple form-based tasks, because the user experience was very limited. New web standards, and better support for existing standards across browsers, enabled web applications to offer a decent user experience in mainstream browsers, for a broad range of tasks.
    </p>
    <p>
Web standards slowly evolve to encorporate the latest technologies. It's an unfortunate consequence of the standardization process. Web standards were unable to keep up with the mobile revolution. Web applications, that worked well on PCs, were hardly usable on mobile devices. The bad experience explains why users prefer native apps. The management of native apps on mobile devices is delegated to app stores of vendors, not to individual users, but the distribution of a new app version is still more complex than upgrading a web application. Organizations take this complexity for granted, because they fear unhappy users. 
    </p>
    <p>
A hybrid solution that fetches and presents snippets from the web inside native apps, combines the best of both worlds. The native app is responsible for an intuitive integration with the mobile device OS, while the snippets are easy to manage and to upgrade on web servers. It is a new equilibrium that keeps users and organizations happy.
    </p>
    <p>
The short history of past application architectures is an important lesson for oma. A device-independent architecture, which offers a decent user experience across terminal devices, now and in the future, is unrealistic. Many devices have capabilities that cannot be emulated on other types of devices. The open mainframe architecture encourages experimentation with device-specific features that are captured in emerging web standards. Frontend developers design abstractions that convey the effects of a new web browser technology as delta actions in a virtual user interface. Backend developers employ these abstractions in the virtual user interface to optimize the real user experience on popular devices.
    </p>
    <h2>Typed JSON</h2>
    <p>
The open mainframe architecture augments JSON with a type system to enforce more rigorous rules about structure. Typed JSON is an essential ingredient that glues the components of oma together. The type system introduces a simple definition language to create data types, which specify how to marshal and unmarshal data values in JSON. A data value is either a basic, list, dictionary or record value.
    </p>
    <p>
The dynamic type of a value must be preserved when values are communicated over the wire. The JSON representation of a data value is either compact or full. A <dfn>full representation</dfn> includes the dynamic type of the represented value. A <dfn>compact representation</dfn> is on the other hand untyped. Consider the list type <code>[string]</code>. The compact representation of an empty string list is an empty array <code class="literal">[]</code>. The full representation is a JSON object <code class="literal">{$:'[string]',_:[]}</code>. The dollar entry expresses the dynamic type of the value and the underscore entry represents the untyped value. Although a compact JSON representation is preferable, a full representation is unavoidable when the dynamic type of a value on the wire cannot be inferred.
    </p>
    <p>
A terminal loads modules that define data types for virtual user-interface elements like buttons and sliders. The terminal loads other modules that implement real user-interface elements in JavaScript. These implementations are known as manifestations in oma terminology. A <dfn>manifestation</dfn> determines how a data value in a session model behaves in a runtime environment. Manifestations separate structural from behavioral concerns. A virtual slider element in a session model is unaware of its manifestation in the browser DOM, which presents a real slider the user can interact with.
    </p>
    <h2>Multidisciplinary teams</h2>
    <p>
Applications are the responsibility of teams. The open mainframe architecture carefully balances the needs of all team disciplines that are involved in an application's lifecycle.
    </p>
    <p>
Frontend developers are responsible for the manifestations of virtual user-interface elements in a browser environment. Backend developers write application logic to control virtual user interfaces. The modular organization of assets streamlines cooperation between these disciplines in a team. They have to agree which module versions are bundled in an application deployment. The <dfn>application image</dfn> of a deployment lists all modules that a terminal may need to load when it starts the application.
    </p>
    <p>
A backend developer probably does not change the application image while testing new application logic. It might even be possible to test a new version of the application without redeploying it, depending on the implementation language and development environment. A frontend developer on the other hand, redeploys the same application logic over and over again, but with different images, to test new manifestations in a browser environment. The source assets of these manifestations are conveniently uploaded in heavy deployments. Frontend and backend developers can deploy their applications on a remote mainframe. The impact of oma on development environments should almost be negligible. Developers are not forced to install, maintain and run an open mainframe on their local machines to test their creations. They post an HTTP request for a heavy or light deployment to a remote mainframe, which is an easy feat in many development environments. After successful deployment, developers start the application by navigating a web browser to a welcome URL.
    </p>
    <p>
The early stages of an application's lifecycle focus on frantic development, but at some point, an application deployment should be production-ready. Other disciplines in the team are responsible for maintenance of the production site. Developers still work on the product, but new developments only reach the production site after passing a slew of quality assurance tests. To satisfy the needs of QA team members, an architecture must support isolated deployments of different application versions. URL-based navigation of terminals tackles this issue in oma. As long as an application deployment is reachable at some welcome URL, users can start the application in a terminal and test it. The isolation of datasets and of application code remains a responsibility of the team.
    </p>
    <p>
Team members that manage the network infrastructure are not confronted with a myriad of protocols and technologies in oma, because all communication between tiers is based on HTTP. Large Internet companies demonstrate every day that HTTP, and HTTPS, scales to millions of connections. The following figure shows the network topology of a typical production site in oma. An arrow is the initiation of a TCP connection between networks. The mainframe network is a demilitarized zone (DMZ), separated from frontend and backend networks. The frontend firewall filters connections from the Internet, it handles encryption of HTTPS connections and it serves static assets. Other HTTP requests from the Internet are forwarded to an address, or multiple addresses, in the mainframe network. Backend firewalls similarly filter, forward and balance HTTP requests from networks where deployed applications are running.
    </p>
    <table class="network-stack">
      <tbody>
        <tr class="network layer">
          <td colspan="7">
Internet
          </td>
        </tr>
        <tr class="network-flow">
          <td colspan="7">
&darr;
          </td>
        </tr>
        <tr class="firewall layer">
          <td colspan="7">
Frontend firewall
          </td>
        </tr>
        <tr class="network-flow">
          <td colspan="2">
&darr;
          </td>
          <td colspan="3">
&darr;
          </td>
          <td colspan="2">
&darr;
          </td>
        </tr>
        <tr class="network layer">
          <td colspan="7">
Mainframe network
          </td>
        </tr>
        <tr class="network-flow">
          <td>
&uarr;
          </td>
          <td>
&uarr;
          </td>
          <td>
&uarr;
          </td>
          <td class="network-separator" />
          <td>
&uarr;
          </td>
          <td>
&uarr;
          </td>
          <td>
&uarr;
          </td>
        </tr>
        <tr class="firewall layer">
          <td colspan="3">
Backend firewall<sub>1</sub>
          </td>
          <td class="network-separator" />
          <td colspan="3">
Backend firewall<sub>2</sub>
          </td>
        </tr>
        <tr class="network-flow">
          <td colspan="3">
&uarr;
          </td>
          <td class="network-separator" />
          <td colspan="3">
&uarr;
          </td>
        </tr>
        <tr class="network layer">
          <td colspan="3">
Local network<sub>1</sub>
          </td>
          <td class="network-separator" />
          <td colspan="3">
Local network<sub>2</sub>
          </td>
        </tr>
      </tbody>
    </table>
    <h2>Application domains</h2>
    <p>
Mainframes are traditionally used in administrative domains. Although the open mainframe architecture is more domain agnostic, there are inherent limitations.
    </p>
    <p>
Developers should be careful not to neglect the Law of Leaky Abstractions. It is tempting to treat a virtual user interface as an event-driven user interface, but the separation of presentation and application concerns on distinct networks is not an insignificant implementation detail. When a user interaction takes place in a terminal, there is a network delay before a backend process is informed about a delta action in a virtual user interface. There is yet another network delay before the effects in the user interface are reported back to the terminal and manifested in the DOM. Network delays are measured in milliseconds. Event-driven user interfaces in native window system react within microseconds. A thousandfold difference cannot be ignored. A virtual user interface is bound to leak if the network is not an integral part of its design.
    </p>
    <p>
When designing virtual user interfaces, team members divide responsibilities between presentation logic in frontend terminals and application logic in backend processes. They negotiate a balance that supports an intuitive user experience on terminal devices with average network connectivity. User perception must be the decisive factor to resolve design issues. This may involve optimistic trickery like starting an animation in a terminal to show results, before the backend process has produced the results. Leave it to the imagination of creative teams to design virtual user interfaces for a broad range of application domains.
    </p>
    <h2>Share and enjoy</h2>
    <p>
The open mainframe architecture is released under the liberal MIT license. Developers are encouraged to examine the sources of the reference implementation. The reference implementation of oma complements the service descriptions in this document with an executable prototype. This is a vital instrument for developers that wish to implement oma components in their favorite programming languages. Developers are of course also able to contribute to the quality of the reference implementation itself. The JavaScript sources should communicate the philosophy of oma as clearly as possible.
    </p>
    <p>
In memory of Douglas Adams, oma adopts the slogan of the Sirius Cybernetics Corporation. Share and enjoy!
    </p>
    <h1>Delta service</h1>
    <p>
The delta service is the beating heart of oma. A client and server side, sharing and synchronizing a model, is a recurring theme in the architecture. Terminal, application and process sessions are delta sessions, albeit with different models and/or directions. This chapter explains how data types describe the JSON structure of session models, how delta sessions map to HTTP resources on a web server, and how the delta protocol expects the client and server side to behave.
    </p>
    <h2>Data types</h2>
    <p>
The model of a delta session is the placeholder for a typed data value. Data types restrict what kind of actions clients and servers can perform on models, e.g. a number cannot be stored at a location that expects a string. Record types specify additional field annotations. These annotations define whether the client, the server, or both sides of the session can modify a record field. By default, the server side can change a field, but the client cannot. The annotations also distinguish between data and event fields in a model. A <dfn>data field</dfn> is the placeholder for a data value. An <dfn>event field</dfn> is the origin of a transient event. Events are reported in delta messages, but they are not persisted in the session model.
    </p>
    <p>
The following data types define the structure of values.
    </p>
    <ul>
      <li>
        <p>
The basic types are <code>none</code>, <code>boolean</code>, <code>number</code> and <code>string</code>. The only member of <code>none</code> is <code class="literal">null</code>.
        </p>
      </li>
      <li>
        <p>
An optional type, denoted with a closing question mark, adds <code class="literal">null</code> as a type member. Members of optional type <code>boolean?</code> are either <code class="literal">true</code>, <code class="literal">false</code> or <code class="literal">null</code>.
        </p>
      </li>
      <li>
        <p>
A wildcard type, denoted with an asterisk, matches all types without a <code class="literal">null</code> member. An optional wildcard type <code>*?</code> matches any type.
        </p>
      </li>
      <li>
        <p>
An enumeration type enumerates one or more distinct string choices. Enumerated choices are surrounded by double quotes and separated by underscores, e.g. <code>"a"_"b"_"c"</code>.
        </p>
      </li>
      <li>
        <p>
A list type surrounds an element type with square brackets. A member of list type <code>[string]</code> is a sequence of basic strings.
        </p>
      </li>
      <li>
        <p>
A dictionary type surrounds an element type with angle brackets. A member of dictionary type <code>&lt;number&gt;</code> maps string keys to basic numbers.
        </p>
      </li>
      <li>
        <p>
A record type surrounds comma-separated field definitions with curly brackets. A colon associates a name with a type in a field definition. Record type <code>{bar:[number]}</code> defines field <code>bar</code> whose value is a list with numbers.
        </p>
      </li>
      <li>
        <p>
A union type contains type alternatives, separated by vertical bars. A member of union type <code>number|string</code> is either a basic number or string.
        </p>
      </li>
    </ul>
    <h3>Definition language</h3>
    <p>
A delta session exports a <dfn>typespace</dfn> that binds names to type expressions and macros. A <dfn>type expression</dfn> is evaluated in a typespace. A <dfn>type macro</dfn> is a template that needs one or more type parameters to evaluate the resulting data type. Both sides of a session parse and evaluate the expressions and macros of the typespace to establish a common vocabulary for model synchronization. Typespaces add a convenient level of indirection to organize and to reuse type definitions in oma, for example type additions to merge the fields of record types.
    </p>
    <p>
The definitions in a typespace must be closed under evaluation. Every type variable in an expression must be bound to a macro argument. Every type name must be bound to a macro or expression in the typespace. The complete grammar of type definitions is given below in EBNF notation.
    </p>
<pre>TypeDef     =  TypeMacro | TypeExpr
TypeMacro   =  <span class="literal">"("</span> TypeArg {<span class="literal">","</span> TypeArg} <span class="literal">")"</span> TypeExpr
TypeArg     =  <span class="pattern">VARIABLE</span> <span class="literal">"="</span> TypeExpr
TypeExpr    =  TypeExpr<sub>1</sub> [<span class="literal">"?"</span>]
TypeExpr<sub>1</sub>   =  TypeExpr<sub>2</sub> {<span class="literal">"|"</span> TypeExpr<sub>2</sub>}
TypeExpr<sub>2</sub>   =  TypeExpr<sub>3</sub> {<span class="literal">"+"</span> TypeExpr<sub>3</sub>}
TypeExpr<sub>3</sub>   =  TypeExpr<sub>4</sub> | <span class="pattern">VARIABLE</span> | <span class="pattern">NAME</span> [<span class="literal">"("</span> TypeExpr {<span class="literal">","</span> TypeExpr} <span class="literal">")"</span>]
TypeExpr<sub>4</sub>   =  <span class="literal">"*"</span> | BasicType | EnumType | ListType | DictType | RecordType
BasicType   =  <span class="literal">"none"</span> | <span class="literal">"boolean"</span> | <span class="literal">"number"</span> | <span class="literal">"string"</span>
EnumType    =  <span class="pattern">CHOICE</span> {<span class="literal">"_"</span> <span class="pattern">CHOICE</span>}
ListType    =  <span class="literal">"["</span> TypeExpr <span class="literal">"]"</span>
DictType    =  <span class="literal">"&lt;"</span> TypeExpr <span class="literal">"&gt;"</span>
RecordType  =  <span class="literal">"{"</span> [Fields] <span class="literal">"}"</span>
Fields      =  Field {<span class="literal">","</span> Field}
Field       =  <span class="pattern">FIELD</span> <span class="literal">":"</span> TypeExpr {Annotation}
Annotation  =  <span class="literal">"@"</span> <span class="pattern">FIELD</span> <span class="literal">"="</span> <span class="pattern">FIELD</span></pre>
    <p>
The token patterns are defined by the following regular expressions.
    </p>
<pre><span class="pattern">NAME</span>      [<span class="literal">A</span>-<span class="literal">Z</span>][<span class="literal">0</span>-<span class="literal">9</span><span class="literal">A</span>-<span class="literal">Z</span><span class="literal">a</span>-<span class="literal">z</span>]+(<span class="literal">.</span>[<span class="literal">A</span>-<span class="literal">Z</span>][<span class="literal">0</span>-<span class="literal">9</span><span class="literal">A</span>-<span class="literal">Z</span><span class="literal">a</span>-<span class="literal">z</span>]+)*
<span class="pattern">FIELD</span>     [<span class="literal">a</span>-<span class="literal">z</span>][<span class="literal">0</span>-<span class="literal">9</span><span class="literal">A</span>-<span class="literal">Z</span><span class="literal">a</span>-<span class="literal">z</span>]*
<span class="pattern">VARIABLE</span>  [<span class="literal">A</span>-<span class="literal">Z</span>]
<span class="pattern">CHOICE</span>    <span class="literal">"</span>[<span class="literal">0</span>-<span class="literal">9</span><span class="literal">A</span>-<span class="literal">Z</span><span class="literal">a</span>-<span class="literal">z</span>]+<span class="literal">"</span></pre>
    <p>
Data types are defined in module configurations. The following JavaScript example shows how the standard type names are defined.
    </p>
<pre><span class="keyword">function</span> configure(module) {
  module.datatype = {
    Any: <span class="literal">'*?'</span>, <span class="comment">// any value, including null</span>
    Flag: <span class="literal">'"y"?'</span>, <span class="comment">// truthy flags</span>
    Text: <span class="literal">'string|[string]'</span>, <span class="comment">// line(s) of text</span>
    List: <span class="literal">'(T=Any)[T]'</span>, <span class="comment">// sequenced list</span>
    Dict: <span class="literal">'(T=Any)&lt;T&gt;'</span>, <span class="comment">// dictionary mapping</span>
    Maybe: <span class="literal">'(T=*)T?'</span>, <span class="comment">// perhaps null</span>
    Record: <span class="literal">'{}'</span> <span class="comment">// empty record</span>
  };
}</pre>
    <p>
The remainder of this document employs a terse notation to bind names to type definitions. The next example shows the previous definitions in this notation. The translation to the corresponding JavaScript in a module configuration is trivial.
    </p>
<pre>Any: *?
Flag: "y"?
Text: string | [string]
List(T=Any): [T]
Dict(T=Any): &lt;T&gt;
Maybe(T=*): T?
Record: {}</pre>
    <p>
Data type <code>Any</code> matches any type, including optional ones. Data type <code>Flag</code> is a boolean-like type, where <span class="literal">null</span> stands for false and <span class="literal">"y"</span> for true. Data type <code>Text</code> avoids problems with newline characters <span class="literal">"\n"</span> and <span class="literal">"\r"</span>. A new line of textual data is represented as an additional string in the list. The standard macros <code>List</code>, <code>Dict</code> and <code>Maybe</code> construct list, dictionary and optional types. For example, <code>Maybe(number)</code> is a more verbose way to express <code>number?</code>. When a macro is evaluated without actual arguments, the formal arguments are bound to their default types. The expression <code>List</code> is thus a shorthand for <code>List(Any)</code>. Data type <code>Record</code> matches any record type.
    </p>
    <h3>Type evaluation</h3>
    <p>
It's not possible to make an optional type more optional. It is syntactically already impossible, i.e. <code>T??</code> is not a valid type expression, but the evaluation of a type expression can still run into this problem. Optionality must be an idempotent operation in a typespace.
    </p>
<pre><span class="rule-condition">S = T?<br/>T = U?</span><span class="rule-conclusion">S = U?</span></pre>
    <p>
An optional <code>none</code> type is nonsensical. An optional value is either <code class="literal">null</code> or a member of the <dfn>mandatory type</dfn>. This assumes the mandatory type describes other values than <code class="literal">null</code>, which excludes <code>none</code>.
    </p>
<pre><span class="rule-condition">S = none?</span><span class="rule-conclusion">S = none</span></pre>
    <p>
Type addition <code>S</code> combines the fields of record types <code>T</code> and <code>U</code>. If a field is defined in both <code>T</code> and <code>U</code>, the field definition from <code>U</code> ends up in addition <code>S</code>. The field of <code>U</code> is said to refine the inherited field of <code>T</code>. The refined field type is not restricted by the inherited field type.
    </p>
<pre><span class="rule-condition">S = T + U</span><span class="rule-conclusion">S = { fields from T and not in U, &hellip;, fields from U, &hellip; }</span></pre>
    <p>
A <code>none</code> alternative lifts a union type to an optional type. Union types cannot have a <code>none</code> alternative.
    </p>
<pre><span class="rule-condition">S = T | none</span><span class="rule-conclusion">S = T?</span></pre>
    <p>
An optional alternative lifts a union type to an optional type. Union types cannot have optional alternatives. Optional alternatives must be replaced by mandatory types in the lifted union type <code>S<sub>1</sub></code>.
    </p>
<pre><span class="rule-condition">S = T | U<br/>T = V?</span><span class="rule-conclusion">S<sub>1</sub> = V | U<br/>S = S<sub>1</sub>?</span></pre>
    <p>
A wildcard alternative lifts a union type to a wildcard type. Union types cannot have a wildcard alternative.
    </p>
<pre><span class="rule-condition">S = T | *</span><span class="rule-conclusion">S = *</span></pre>
    <p>
A union type flattens alternatives. Union types cannot nest union alternatives.
    </p>
<pre><span class="rule-condition">S = T | U<br/>T = V | W</span><span class="rule-conclusion">S = V | W | U</span></pre>
    <p>
A union type merges enumeration alternatives. The distinct choices of enumeration alternatives are merged in one enumeration type. At most one enumeration alternative is allowed in a union type.
    </p>
<pre><span class="rule-condition">S = T | "u<sub>1</sub>"_"u<sub>2</sub>" &hellip; _"u<sub>n</sub>"<br/>T = "t<sub>1</sub>"_"t<sub>2</sub>" &hellip; _"t<sub>m</sub>"</span><span class="rule-conclusion">S = "t<sub>1</sub>"_"t<sub>2</sub>" &hellip; _"t<sub>m</sub>"_"u<sub>1</sub>"_"u<sub>2</sub>" &hellip; _"u<sub>n</sub>"</span></pre>
    <p>
An enumeration alternative is pointless, if basic type <code>string</code> is another alternative, because an enumeration is a subtype of <code>string</code>.
    </p>
<pre><span class="rule-condition">S = T | string<br/>T = "t<sub>1</sub>"_"t<sub>2</sub>" &hellip; _"t<sub>m</sub>"</span><span class="rule-conclusion">S = string</span></pre>
    <p>
Duplicate alternatives are superfluous. Union types cannot specify identical alternatives.
    </p>
<pre><span class="rule-condition">S = T | T</span><span class="rule-conclusion">S = T</span></pre>
    <p>
The evaluation of a recursive type expression should abort with an error message if the expression cannot be reduced to a cyclic type.
    </p>
<pre><span class="rule-condition">S = &hellip; S &hellip; </span><span class="rule-conclusion">cyclic S or evaluation error</span></pre>
    <h3>Marshal and unmarshal</h3>
    <p>
The unmarshal function of a type constructs a data value from a JSON representation. The marshal function is the inverse function from data value back to JSON representation. Marshalling a data value and unmarshalling the resulting JSON representation should produce an equal value. Data values are equal, if and only if they are structurally equal and they are members of the same dynamic type.
    </p>
    <p>
The marshal and unmarshal function of a basic type is the identity function. The compact JSON representation of a basic value cannot be distinguished from the value itself. Consequently, basic values cannot carry dynamic type information. A typespace can define an alias for a basic type, but a basic value cannot be a member of the type alias. The dynamic type of a basic value is implicitly encoded in the value.
    </p>
    <p>
Members of enumeration types are represented as JSON strings, and thus by default, reconstructed as basic string values. This loss of type information is not a problem, if the construction site expects an enumerated choice. Record type <code>Foo</code> in the next example expects basic string <code class="literal">"a"</code> or <code class="literal">"b"</code> when a value for field <code>bar</code> is constructed. The type information, required to validate a basic string as an enumerated choice, is inferred from the construction site. 
    </p>
<pre>Foo: {
  bar: "a"_"b"
}</pre>
    <p>
Unmarshal functions of list, dictionary, record, optional and union types accept a compact JSON representation, when the dynamic type of a data value can be inferred from the construction site. Otherwise the full representation is required to preserve the dynamic type of the value. Type preservation solves contravariance problems when data values in session models are subjected to mutations. The dynamic type of a model value also determines the manifestation in a runtime environment. A session model will not exhibit the intended behavior, if type information is not properly preserved.
    </p>
    <p>
The compact representation of a list value is a JSON array. The full representation stores this array in the underscore entry of a JSON object. The list type is expressed in the dollar entry. List values benefit the most from a compact representation, because it avoids the creation of a wrapper object. For example, the array <code class="literal">[4,2]</code> is a compact representation for a value of list type <code>[number]</code>. The full representation <code class="literal">{$:'[number]',_:[4,2]}</code> wraps the array in an extra object to preserve the dynamic type of the list value.
    </p>
    <p>
The only difference between the compact and full representation of a record value is the missing dollar entry in the compact representation. Both representations are JSON objects. The full representation <code class="literal">{$:'Foo',bar:'b'}</code> includes the dynamic type of a record value, which is dropped from the compact representation <code class="literal">{bar:'b'}</code>. The benefits of a compact representation are noticeable when record values have few fields. If records have many fields, the penalty for extra dollar entries in full representations is negligible.
    </p>
    <p>
The marshal function of a record type does not include a data field in the JSON representation, if the field value is <code class="literal">null</code>. The unmarshal function of a record type initializes a data field to <code class="literal">null</code>, if the field is not present in the JSON representation. This optimization turns standard type <code>Flag</code> into an efficient type for boolean-like fields with a bias towards false. A cleared flag, i.e. the common case, is missing, but a set flag must be explicitly initialized to <code class="literal">"y"</code> in the JSON representation. Record types often define <code class="literal">null</code> as the default field value to optimize JSON representations.
    </p>
    <p>
The compact representation of a dictionary value is a JSON object with an underscore entry that contains another JSON object. The nested JSON object maps dictionary keys to values. Dictionary entries cannot be represented in the root JSON object, because this results in an ambiguous representation when a dollar and/or an underscore is a dictionary key. Full representations of dictionaries employ the same scheme as list values, i.e. a dollar for the type information and an underscore for the untyped container with elements. The full representation of an empty dictionary with numbers is <code class="literal">{$:'&lt;number&gt;',_:{}}</code>. The omission of the dollar entry in the compact representation <code class="literal">{_:{}}</code> is similar to record values.
    </p>
    <p>
The unmarshal function of an inferred optional type accepts a compact representation, if the dynamic type is the same as the inferred mandatory type. An optional value, that is not <code class="literal">null</code>, must be a member of the mandatory type. For example, when the inferred type is <code>Foo?</code>, the compact representation <code class="literal">{bar:'a'}</code> suffices to preserve record type <code>Foo</code>.
    </p>
    <p>
The unmarshal function of an inferred union type accepts the compact representation of a list, dictionary or record value, if there is only one list, dictionary or record alternative to choose from. Standard type <code>Text</code> is the union type <code>string|[string]</code>. The compact representation of a <code>Text</code> value with two lines, e.g. <code class="literal">['One','Two']</code>, cannot be confused with a string alternative for one-liners. However, the unmarshal function of a union type with two or more list alternatives expects a full representation, because it is not always possible to reconstruct the dynamic type of a value from a compact representation. The unmarshal function of union type <code>[number]|[string]</code> does not accept a compact JSON array. An empty array could be an empty list with numbers or with strings.
    </p>
    <h3>Field annotations</h3>
    <p>
A record field is annotated to specify field characteristics in a delta session. A field without annotations is a data field that the server side can update. When a session model is a record value of type <code>Foo</code>, the server side can send an action in a delta response that assigns a new number to field <code>bar</code>. The client side can only read the number in the model.
    </p>
<pre>Foo: {
  bar: number
}</pre>
    <p>
An <code>@event</code> annotation specifies an event field. The annotation value is <code>client</code> or <code>server</code>. Record types do not marshal event fields in JSON. In the next example, field <code>bar</code> is a server event field. The server reports an occurence of this event in a delta response. Field type <code>none</code> implies an occurence is unstructured. The client is informed about an occurence, but the reported event does not provide any additional information.
    </p>
<pre>Foo: {
  bar: none @event=server 
}</pre>
    <p>
A client event field is the origin of an event in a delta request. In the next example, the client informs the server about an occurence of event field <code>bar</code> as soon as possible, which is the default client reaction to an event occurence. The field type indicates an occurence conveys a boolean value.
    </p>
<pre>Foo: {
  bar: boolean @event=client 
}</pre>
    <p>
A <code>@delay</code> annotation alters the client reaction to an event occurence. The annotation value is <code>block</code>, <code>flush</code> or <code>forever</code>. The client sends a delta request with an occurence of event field <code>bar</code> in the next example as soon as possible. Unlike the default non-blocking reaction, a blocked client is not allowed to modify the session model while it awaits the delta response. The model is locked and the client has to wait for the server to produce the side effects of processing the event.
    </p>
<pre>Foo: {
  bar: boolean @event=client @delay=block
}</pre>
    <p>
The client buffers an occurence of event field <code>bar</code> in the next example. The actions in this buffer are flushed and added to the request, when the client sends the next delta request. The server is not informed about buffered actions until the client flushes.
    </p>
<pre>Foo: {
  bar: boolean @event=client @delay=flush
}</pre>
    <p>
The server is not interested in the occurence of event field <code>bar</code> in the next example. It expects the client to delay occurences indefinitely. The server has to delete or update the <code>@delay</code> annotation if it wants to be informed about occurences.
    </p>
<pre>Foo: {
  bar: boolean @event=client @delay=forever
}</pre>
    <p>
The initial value of a <dfn>meta field</dfn> is a dictionary that holds the specified annotations of a field definition. A member of record type <code>Foo</code> with field <code>bar</code> also contains meta field <code>@bar</code>, which maps annotation names to values. The type of a meta field is predefined as <code>&lt;string&gt;</code>, but in all other regards, a meta field is a regular data field that the server side can target with delta actions.
    </p>
    <p>
A <code>@data</code> annotation specifies a data field that is modifiable on the client side. The annotation value is <code>client</code> or <code>both</code>. In the next example, both client and server can update data field <code>bar</code> in a session model with a new string value. When the client changes the field, the default reaction is to report the modification in a delta request as soon as possible. The default reaction is immediate, but non-blocking.
    </p>
<pre>Foo: {
  bar: string @data=both
}</pre>
    <p>
A <code>@delay</code> annotation specifies an alternative client reaction to a data modification. The annotation value is <code>block</code>, <code>flush</code>, <code>pause</code> or <code>ponder</code>. The values <code>block</code> and <code>flush</code> have the same meaning for data and event fields. In the next example, the client buffers a modification of field <code>bar</code>. When this modification is still the most recent field modification after a small pause, the client sends a delta request as soon as possible. The value <code>ponder</code> increases the delay of the last modification to a few seconds, giving the client more time to think about what the field value should be, before the server is informed about it.
    </p>
<pre>Foo: {
  bar: string @data=both @delay=pause
}</pre>
    <p>
When the client owns a data field, the server cannot modify the field value in a session model. Although the server conceptually owns the whole model, the server only computes the initial value of field <code>bar</code> in the next example. Once the field value is part of the model, the client becomes the sole owner. The field annotations, contained in meta field <code>@bar</code>, remain under server control.
    </p>
<pre>Foo: {
  bar: string @data=client @delay=block
}</pre>
    <h2>Delta session</h2>
    <p>
Delta sessions are directories on web servers of open mainframes. The delta service hosts a number of HTTP resources for a delta session. An HTTP client accesses a session resource to initiate a session operation. Many session operations use data types to describe parameters and results.
    </p>
    <h3>Update model</h3>
    <p>
The client and server side of a delta session update a shared model.
    </p>
    <h4><code>POST <span class="variable">session</span>/do</code></h4>
    <p>
The most prominent session resource is <code>do</code> that performs delta actions on the model. The body of an HTTP request encodes the compact JSON representation of a delta message. The HTTP response contains the compact representation of the next delta message. HTTP requests contain delta requests in forward sessions. They contain delta responses in reverse sessions.
    </p>
    <p>
The sequence number of a <code>Delta.Message</code> is an integer that distinguishes between a delta request and response. Requests have positive, odd sequence numbers. Responses have nonnegative, even sequence numbers. A delta message is denoted as &#x03b4;(n) in this document, where n is a sequence number, e.g. &#x03b4;(1) is the first delta request from the client. The actions of response &#x03b4;(2m) reflect side effects that resulted from processing actions of request &#x03b4;(2m-1). The first delta response &#x03b4;(0) from the server assigns the initial model of a reverse session. Field <code>lease</code> counts the number of seconds the receiver of a message has left before it should produce the next delta message. Field <code>retried</code> is truthy if the message was retried after a communication failure.
    </p>
<pre>Delta.Message: {
  sequence: number,
  actions: [Delta.Action],
  lease: number,
  retried: Flag
}</pre>
    <p>
A <code>Delta.Action</code> occurs in some part of the model. Field <code>path</code> locates this part in the model. An array of path elements describes the route from the starting point of the model, i.e. the root value, to the value where the action takes place. When a path element is a string, it selects a record field or dictionary entry for the resolution of the remaining path elements. A numeric path element selects an element from a list value for the remainder of the path. List values have one-based indices.
    </p>
<pre>Delta.Action: { 
  path: [string | number]
}</pre>
    <p>
A <code>Delta.Assign</code> action mutates a value in the model. A <code>Delta.Signal</code> action reports a client or server event in the model. Both assignments and signals must be properly typed. The path of an action infers what type of value can be assigned or what type of event can be signalled. For example, if the path leads to an element of a list in the model, the value to assign must be a member of the element type.
    </p>
<pre>Delta.Assign: Delta.Action + {
  value: Any
}
Delta.Signal: Delta.Action + {
  event: Any
}</pre>
    <p>
A <code>Delta.Replace</code> action works on a list value in a session model. The path of a replacement action locates the position in the list where action values replace existing elements in the model. A <code>Delta.Delete</code> action specifies keys to remove from a dictionary value in the model.
    </p>
<pre>Delta.Replace: Delta.Action + {
  values: [Any]
}
Delta.Delete: Delta.Action + {
  keys: [string]
}</pre>
    <p>
A <code>Delta.Goto</code> action jumps to a location in the model from where the other relative actions are performed. A <code>Delta.Update</code> action fuses several assignments into a single action. Field <code>assigns</code> is a dictionary whose entry keys specify the assignment locations for entry values. If the path of an update action locates a record or dictionary in the session model, the assignment keys identify record fields or dictionary entries. If a list is located at the update path, the assignment keys are string representations of integer indices. Goto and update actions are optimizations that avoid path duplications to minimize the payload of delta messages.
    </p>
<pre>Delta.Goto: Delta.Action + {
  actions: [Delta.Action]
}
Delta.Update: Delta.Action + {
  assigns: &lt;Any&gt;
}</pre>
    <h3>Query session</h3>
    <p>
Query operations are nonintrusive. They cannot affect the session state in any way.
    </p>
    <h4><code>GET <span class="variable">session</span>/poll</code></h4>
    <p>
An HTTP client polls a delta session to inspect the current session status. The client cannot cache the HTTP response that contains the compact JSON representation of a <code>Delta.Status</code> record. Field <code>expects</code> is the sequence number of a delta message. When even, the server side is supposed to produce the next delta response. Otherwise the client side should come up with the next delta request.  Field <code>after</code> counts how many lease seconds are remaining for the producing side. A negative <code>after</code> value means the next message is overdue. The absolute value counts how many seconds the producing side is late.
    </p>
<pre>Delta.Status: {
  expects: number,
  after: number
}</pre>
    <h4><code>GET <span class="variable">session</span>/model</code></h4>
    <p>
An HTTP client sends a request to this resource to obtain the definition of data type <code>Delta.Model</code>, which describes the root value of a delta session. The client should cache the HTTP response with the textual source of a type definition. The model of a session holds a list, dictionary or record value. This composed value is the starting point to manipulate the session model. The type of the root value is used in standard types, but it lacks a standard definition.
    </p>
    <h4><code>GET <span class="variable">session</span>/dump</code></h4>
    <p>
A dump operation returns the complete state of a session. An HTTP client should not cache the response with the compact representation of a <code>Delta.Dump</code> record. The record combines the status of a session with the root value. A dump enables restoration of a session model. A browser must restore the model of a terminal session after a page refresh has destroyed the old model.
    </p>
<pre>Delta.Dump: Delta.Status + Delta.Root
Delta.Root: {
  root: Delta.Model
}</pre>
    <h4><code>GET <span class="variable">session</span>/types</code></h4>
    <p>
Both sides of a delta session parse and evaluate type definitions. This resource exports the typespace of a session, minus the definition of <code>Delta.Model</code>. The HTTP response contains a JSON object that maps names to sources of type expressions and macros. An HTTP client should cache the response. The removal of <code>Delta.Model</code> allows reuse of the other type definitions in a typespace. For example, this resource exports exactly the same JSON object in an application session as it exports in a process session of the application.
    </p>
    <h3>Manipulate lease</h3>
    <p>
The easiest way to simulate bidirectional synchronization is to specify tiny lease periods in delta messages. This gives the illusion that any side can change the model at any time. Unfortunately, it also causes a lot of superfluous delta messages, if the average client and server perform actions on the session model at a much lower frequency than they exchange delta messages. The ready and greedy resource of a delta session provide a more efficient solution.
    </p>
    <h4><code>GET <span class="variable">session</span>/ready</code></h4>
    <p>
If an HTTP client has a reasonable amount of lease time left to send the next delta message, it can send a request to this session resource. The HTTP response, which cannot be cached, may take a while to arrive, but when it arrives before the lease period expires, it contains the new lease time. A zero lease time enables the other side to instruct the HTTP client to send the next delta message right away. The other side can influence the lease period without altering the sequential flow of delta messages. It is still up to the HTTP client to produce the next delta message when the lease period expires. 
    </p>
    <h4><code>GET <span class="variable">session</span>/greedy</code></h4>
    <p>
If the other side still has a reasonable amount of lease time left to produce the next delta message, an HTTP client can send a request to this session resource. The HTTP response contains the remaining lease time for the other side. It cannot be cached. If the response contains a zero, the lease time was successfully reset, and the HTTP client should receive the next delta message shortly. If the response contains a positive number, the lease time could not be reset. The HTTP client may have to wait for the lease period to expire before it receives the next delta message. A negative number indicates the next delta message from the other side is already overdue.
    </p>
    <h3>Upload file</h3>
    <p>
The client side of a paired session uploads files that the server side downloads. When a frontend terminal uploads files, the backend process downloads them. The delta service maintains a <dfn>binary pipe</dfn> to transfer the files from the client to the server side. The transfer is coordinated with delta events in the session model, but the binary file content is never stored in the model.
    </p>
    <h4><code>POST <span class="variable">session</span>/plumb</code></h4>
    <p>
The server side of a paired session posts an HTTP request to this resource to create a binary pipe. The response body is a string with the name of a new pipe. Pipe creation is probably triggered by some upload event in a delta request, which describes the files the client side wants to upload, although this is not enforced. The server side is allowed to create a binary pipe at any time.
    </p>
    <h4><code>GET <span class="variable">session</span>/pipe/<span class="variable">name</span></code></h4>
    <p>
A pipe is an HTTP resource in the <code>pipe</code> subdirectory of a paired delta session. The name of the resource was determined when the pipe was created earlier. The server side sends an HTTP request to download files from the pipe resource. The <code>multipart/form-data</code> body of the response encodes the files.
    </p>
    <h4><code>POST <span class="variable">session</span>/pipe/<span class="variable">name</span></code></h4>
    <p>
The client side of a paired session posts an HTTP request with a <code>multipart/form-data</code> body to upload files to a pipe resource. The pipe name must have been communicated with some push event in a delta response, which instructs the client side to initiate the upload. The pipe name is not stored in the session model with an assignment, because pipes are transient channels. If a browser window is refreshed while uploading files, the upload channels are destroyed.
    </p>
    <p>
The visualization of file uploads in virtual user interfaces, e.g. progress bars, is controlled by backend processes. The pipes of a paired session operate independently from the delta messages that the client and server side exchange.
    </p>
    <h3>Download file</h3>
    <p>
The coordination with delta events enables the server side to create a pipe for an uploading client, but a similar coordination cannot be realized for a downloading client. A terminal cannot tell when a browser actually sends an HTTP request to download a file, because it depends on unknown factors, e.g. the volatile state of the browser cache. The URL of a downloaded file would furthermore be confined to a terminal session. Terminals would not be able to share files, even if the terminals belong to the same user.
    </p>
    <p>
A forward delta session can own a directory with cached files. Unlike a binary pipe with a paired reader and writer, a cache has many readers and one owner that writes content. Frontend terminals are readers that download files from the cache of a backend application. The application is the owner, which fills the cache with files that cannot be published in public library bundles. Cached files have dynamically generated and/or sensitive content, for example financial reports.
    </p>
    <p>
When an HTTP client attempts to download a cached file, the delta service verifies the download request originates from an authentic cache reader, i.e. a terminal whose user is running the application. If not, the HTTP client is informed that the resource could not be found. If the request has an authentic origin, the user must be authorized to access the cached file. Authorization is coordinated with delta events in the session model of the cache owner. The delta service generates an event that describes users accessing files. The event conveys a dictionary value that maps file names to <code>Delta.Access</code> records. Field <code>content</code> is the current status of the file in the cache. Field <code>guests</code> identifies the users that are attempting to download the file.
    </p>
<pre>Delta.Access: {
  content: "cached"_"allocated"_"unknown",
  guests: [string]
}</pre>
    <p>
The cache owner signals an authorization event back that grants and revokes access to cached files. The event contains a dictionary that maps file names to <code>Delta.Authorization</code> records. Fields <code>allows</code> and <code>denies</code> specify lists of users with authorized and unauthorized access to the cached file.
    </p>
<pre>Delta.Authorization: {
  allows: [string],
  denies: [string]
}</pre>
    <p>
The delta service can purge cache entries, but it does not maintain a history of purged names. When the delta service generates an event that describes guests accessing cached files, the event contains the status of files in the cache. The cache owner should revoke access to any unknown files it encounters, but it should restore purged files in the cache if their access is granted. The owner must ensure restored files are identical to purged files.
    </p>
    <h4><code>POST <span class="variable">session</span>/alloc</code></h4>
    <p>
A cache owner posts an HTTP request to this resource, when it wants to add a file to the cache. The request body encodes the compact JSON representation of a <code>Delta.File</code>. The textual body of the HTTP response is the name of a new cache entry. The allocated name allows the URL of a cached file to be derived before the file content has been copied to the cache.
    </p>
    <p>
A <code>Delta.File</code> record describes binary content of a file. Field <code>local</code> contains a suggestion for a local file name when cache readers save cached content. The size is measured in bytes. An empty type indicates an unknown MIME type.
    </p>
<pre>Delta.File: {
  local: string?,
  size: number,
  type: string
}</pre>
    <h4><code>POST <span class="variable">session</span>/cache</code></h4>
    <p>
When a cache owner needs to restore purged files in the cache, it posts an HTTP request to this resource. The request body encodes the compact JSON representation of a dictionary that maps maps allocated names of cache entries to <code>Delta.File</code> values.
    </p>
    <h4><code>GET <span class="variable">cache</span>/file/<span class="variable">name</span></code></h4>
    <p>
A frontend terminal is an example of a cache reader. A terminal manifests the URL of a cached file in the DOM, e.g. in an <code>img</code> tag, which causes the browser to send an HTTP request to download the file from the cache. The HTTP response with the file should be privately cached and revalidated on every access. 
    </p>
    <h4><code>PUT <span class="variable">session</span>/file/<span class="variable">name</span></code></h4>
    <p>
A cache owner puts a new file in the cache. The name of the cache entry must have been newly allocated or restored after a purge. The HTTP request body contains the binary content that should be copied to the cache. The file remains cached until the cache entry is purged or the session of the owner is closed.
    </p>
    <h2>Delta protocol</h2>
    <p>
The following scenarios assume this side of a delta session is an HTTP client. The direction of the delta session is irrelevant unless it is explicitly mentioned. Otherwise, the HTTP client is either the client side of a forward session or the server side of a reverse session. Whatever the role of the HTTP client is, the web server on the other side always plays the opposite role in the delta session. It is furthermore assumed that both sides have successfully parsed and evaluated the type expressions and macros of the typespace.
    </p>
    <h3>Happy days</h3>
    <p>
In the happy days scenario, the sequential exchange of delta messages proceeds without problems.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side. The delta message has a lease time that tells the other side how long it can take to reply with &#x03b4;(n+1).
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
After processing the actions of &#x03b4;(n), the other side replies with &#x03b4;(n+1) before the lease period expires.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n+2)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
This side processes the actions of &#x03b4;(n+1), which also contains a deadline for this side to post &#x03b4;(n+2).
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+3)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies on time with &#x03b4;(n+3), completing another cycle of the delta protocol.
        </p>
      </li>
    </ol>
    <p>
The sequential, turn-based exchange of messages simplifies the delta protocol. At any given moment, there is one side of the session that has the initiative to produce the next delta message. The lease period of the last delta message sets a deadline for the producing side, ensuring regular contact between both sides.
    </p>
    <h3>Lost delta message</h3>
    <p>
HTTP relies on TCP for reliable message delivery. An HTTP client can however communicate with a server over multiple TCP connections, reordering the flow of HTTP messages. The route between an HTTP client and server may include a number of proxies, further complicating message delivery. The delta protocol assumes the delivery of a message can fail, without receiving a notification of this communication failure before the lease period expires. 
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="bad-side">&perp;</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side, but the delta message never arrives. The client is not notified of this failure before the lease period of &#x03b4;(n) expires.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
When the HTTP client does not receive the expected &#x03b4;(n+1), it polls the session to see what's going on. The poll request is sent when the lease period expires, with some added slack for very small lease periods. The client should not poll the session before the average delay of three network roundtrips has surpassed. 
        </p>
        <p>
If the lease period of &#x03b4;(n) is fairly large, e.g. a minute, it may take a while before the client polls the session to detect problems. An HTTP client can poll the session to seek early confirmation of successful message delivery. When the poll response reveals the other side is expected to produce &#x03b4;(n+1), the client knows &#x03b4;(n) has been delivered.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">expects &#x03b4;(n)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
In this scenario, the poll response reveals the other side is still expecting the HTTP client to post &#x03b4;(n).
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do retried &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
When the HTTP client knows &#x03b4;(n) hasn't arrived at the other side, it aborts the old HTTP request and it posts a new &#x03b4;(n) with a set <code>retried</code> flag.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The retried &#x03b4;(n) arrives without problems. The other side replies with &#x03b4;(n+1) on time to complete another cycle of the delta protocol.
        </p>
      </li>
    </ol>
    <p>
The previous scenario showed the HTTP client must be able to reproduce &#x03b4;(n) when the last attempt to post &#x03b4;(n) failed. The next scenario shows the other side has the same responsibility after replying with &#x03b4;(n+1). In general, some side of a session should hold on to its last delta message &#x03b4;(m) until it has produced &#x03b4;(m+2) in the next session cycle.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts &#x03b4;(n), which arrives at the other side without problems.
        </p>
      </li>
      <li>
        <span class="bad-side">&perp;</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1) as expected, but this HTTP response is lost.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client polls the session when it does not receive &#x03b4;(n+1) on time.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">expects &#x03b4;(n+2)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The poll response reveals the other side already expects this side to post &#x03b4;(n+2). The HTTP client knows &#x03b4;(n+1) is probably lost.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do retried &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client aborts the old request and it posts a retried &#x03b4;(n). In this scenario, the HTTP client strips all actions from the retried delta message, because it knows the stripped actions have already been processed.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">retried &#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
Although the other side expects &#x03b4;(n+2), it receives a retried &#x03b4;(n). It replies with a retried &#x03b4;(n+1). It ignores any actions that the retried &#x03b4;(n) might contain.
        </p>
      </li>
    </ol>
    <p>
These scenarios demonstrate the importance of nonintrusive polling. When the HTTP client detects a potential problem, it first polls the session to get an accurate picture of the situation before it reacts, e.g. aborting a previously posted delta message.
    </p>
    <h3>Slow delta message</h3>
    <p>
When a lease period expires, there is not necessarily a real problem. A lease period may not correspond with the actual time it takes to process a delta message. For example, a delta request from a terminal usually specifies a tiny or zero lease time, but it is not realistic to assume a backend process can handle all kinds of user interactions almost instantaneously.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts &#x03b4;(n), which arrives at the other side without problems.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client polls the session before it receives &#x03b4;(n+1).
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">expects &#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The poll response reveals the other side is expected to produce &#x03b4;(n+1). The HTTP client can poll the session to seek early confirmation of message delivery when the lease period of &#x03b4;(n) is quite large. In that case, the poll response is a positive confirmation. In the remainder of this scenario, the client polls the session, because the lease period of &#x03b4;(n) has expired. The poll response also reveals &#x03b4;(n+1) is overdue.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client does not abort the posted &#x03b4;(n) when the other side takes too long to produce &#x03b4;(n+1). Polling at regular intervals ensures the loss of &#x03b4;(n+1) is detected.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">expects &#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
Every subsequent poll response reveals the production of &#x03b4;(n+1) takes an increasing amount of time, because the <code>after</code> field of the session status is decreasing as time passes by.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
When the other side finally produces &#x03b4;(n+1), the HTTP client receives a response for the posted &#x03b4;(n) of the first scenario step.
        </p>
      </li>
    </ol>
    <p>
The HTTP client stubbornly waits for the response of the posted &#x03b4;(n). Although an HTTP connection is closed after a certain period of inactivity, it's impossible to predict beforehand when this is going to happen. While repeated polling reveals &#x03b4;(n+1) is still overdue, the HTTP client does not abort the connection. 
    </p>
    <h3>Ready to send next delta message</h3>
    <p>
A ready resource gives the other side control over the lease period, but an HTTP client is not obliged to use it.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1) on time. The lease period, specified in &#x03b4;(n+1), is quite large. The HTTP client has plenty of lease time left after processing the actions of &#x03b4;(n+1).
        </p>      
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">ready<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
In this scenario, the HTTP client sends a ready request to the other side. This side is ready and willing to send the next delta message on demand.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">60 sec<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The ready response from the other side sets a new lease time for this side. The response may take some time to arrive.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">ready<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
With a lease period of one minute, the HTTP client sends another ready request. It is still ready to send the next delta message.
        </p>
      </li>
    </ol>
    <p>
The HTTP client in the next scenario modifies the model.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1) on time.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">ready<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client sends a ready request to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n+2)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
Before receiving a ready response, the HTTP client posts &#x03b4;(n+2), because it wants to synchronize the modified model with the other side. The ready response doesn't matter anymore, and the HTTP client aborts the ready request.
        </p>
      </li>
    </ol>
    <p>
The next scenario shows a ready response with a zero lease time.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1) on time.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">ready<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client sends a ready request to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">0 sec<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The ready response from the other side resets the lease time for this side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n+2)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client immediately posts &#x03b4;(n+2) after receiving the ready response. The delta message may contain an empty action list.
        </p>
      </li>
    </ol>
    <p>
Ready messages can get lost. In the next scenario, the ready request is lost, but the story is the same when the ready response is lost.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1) on time.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">ready<br/>&rarr;</span> <span class="bad-side">&perp;</span>
        <p>
The HTTP client sends a ready request that never arrives at the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n+2)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
When the ready request or response fails, the lease period of &#x03b4;(n+1) inevitably expires. Upon expiration, the HTTP client posts &#x03b4;(n+2) to the other side.
        </p>
      </li>
    </ol>
    <p>
The last scenario explains why ready messages are optional. The lease period of a delta message is a safe fallback when ready messages are not sent or fail to operate.
    </p>
    <h3>Greedy to receive next delta message</h3>
    <p>
A ready request is a form of courtesy, giving the other side an opportunity to overrule the lease period of this side. A greedy request is the exact opposite. An HTTP client sends a greedy request in an attempt to reset the remaining lease period of the other side. 
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side. The lease period of &#x03b4;(n) is reasonably large. The other side will have the initiative to synchronize the model for quite a while.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">greedy<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client sends a greedy request.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">28 sec<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The greedy response from the other side is bad news. A greedy HTTP client wants the initiative to synchronize the model, but this greedy response means it may take another 28 seconds before the other side produces &#x03b4;(n+1).
        </p>
      </li>
    </ol>
    <p>
In the next scenario, the greedy request is satisfied before the greedy response arrives.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">greedy<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client sends a greedy request.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1). The HTTP client aborts the greedy request, because it does not matter anymore.
        </p>
      </li>
    </ol>
    <p>
A zero greedy response implies satisfaction is near.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">greedy<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client sends a greedy request.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">0 sec<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The greedy response from the other side is zero. The lease period of the other side has been reset.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1). If it doesn't arrive as promised, the HTTP client polls the session to detect a slow or lost delta message.
        </p>
      </li>
    </ol>
    <p>
The greedy response is lost in the next scenario.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">greedy<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client sends a greedy request.
        </p>
      </li>
      <li>
        <span class="bad-side">&perp;</span> <span class="delta-message">42 sec<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The greedy response from the other side is lost.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
When the lease period of &#x03b4;(n) expires, the HTTP client polls the session. It also aborts the greedy request that probably failed. At this point, it doesn't matter whether the greedy request or response failed.
        </p>
      </li>
    </ol>
    <p>
Greedy messages complement ready messages in paired delta sessions. A greedy request in a process session yields a zero ready response in the terminal session, if the terminal has previously sent a ready request. The process in the backend is able to pull the next delta request from the terminal in the frontend, even if the terminal has plenty of lease time left and nothing interesting to report.
    </p>
    <h3>Transfer files through pipe</h3>
    <p>
The transfer of files is coordinated with delta events in a paired session.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(2n+1)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The client side of a paired session posts an HTTP request with &#x03b4;(2n+1) to the server side. The delta request contains an upload event with information about files the client wants to upload.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(2n+2)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The server side replies with &#x03b4;(2n+2). The delta response contains a push event with the name of a binary pipe and the names of files to upload in the pipe.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">pipe/aI6Gr<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The client posts an HTTP request to the pipe that was named in the push event. The body of the request encodes the uploaded files.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(2n+3)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
While uploading files, the client posts an HTTP request with &#x03b4;(2n+3). Except for the loss in bandwidth, the exchange of delta messages should not be affected by pipe activity.
        </p>
      </li>
    </ol>
    <p>
In the next scenario, the sides are reversed. This side is the downloading server and the other side is the uploading client in a session pair.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(2n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The server side posts an HTTP request with &#x03b4;(2n) to the client side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(2n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The client side replies with &#x03b4;(2n+1). The delta request contains an upload event with file information.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">plumb<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
In this scenario, the server agrees the files should be uploaded. It posts an HTTP request to create a binary pipe for the file tranfer. 
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">aI6Gr<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The HTTP response contains the name of a new pipe.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(2n+2)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The server side posts an HTTP request with &#x03b4;(2n+2) whose push event informs the client side about the files to upload in the pipe.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">pipe/aI6Gr<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The server side sends an HTTP request to download files from the pipe.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(2n+3)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
While downloading files, the server side receives &#x03b4;(2n+3) from the client side.
        </p>
      </li>
    </ol>
    <p>
A binary pipe transfers files from the client to the server side of a paired delta session. The coordination with an upload and push event prepares the downloading server for the uploading client. The coordination causes a delay, because an extra roundtrip is required to communicate a pipe name before the client kicks off the actual upload. This delay should hardly be noticeable, unless the client and server transfer many small files through separate pipes.
    </p>
    <h3>Cache files</h3>
    <p>
A forward delta session can own a web directory with cached files. File access is coordinated with delta events in the session of the cache owner, although the coordination is not visible to readers that download cached files. An HTTP client simply sends a request to get a file from the directory, regardless whether the file is cached or not.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">alloc<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
This side posts an HTTP request to allocate a unique name in the cache that this side owns.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">pK0vR<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The HTTP response reveals the name of a new file in the cache. This side can now derive the URL of the cached file.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(2n+1)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
This side posts an HTTP request with &#x03b4;(2n+1) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(2n+2)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(2n+2). The delta response contains a download event, which specifies a user attempting to access the cached file that was allocated earlier.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(2n+3)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
This side verifies the user is authorized to access the file. It posts &#x03b4;(2n+3) to the other side with an authorization event that grants access.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">file/pK0vR<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
After the cache owner has granted access to the file, it must put the file content in the cache.
        </p>
      </li>
    </ol>
    <p>
The cache fills up on demand. The content of a cached file is copied when an HTTP client is granted access to download the file, while the content is not yet in the cache. If the content is already cached, this side still authorizes a download attempt, but it should not copy the content again. If this side revokes access, the download of a cached file fails with a status code that indicates the file could not be found. An HTTP client cannot differentiate between a file that is not cached, and a cached file that the client is not authorized to access.
    </p>
    <p>
In the next scenario, the cache owner restores purged files.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(2n+1)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
This side posts an HTTP request with &#x03b4;(2n+1) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(2n+2)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(2n+2). A download event in the delta response specifies a user attempting to access content at cache entry <code>pK0vR</code>, which is neither cached nor allocated.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">cache<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
This side knows the name of the cache entry belongs to a file that the delta service has purged. After verifying the guest is allowed to access the file, the side posts an HTTP request to map the name to the cached file again.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message"><br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The HTTP response indicates the mapping of the name has been successfully restored. 
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(2n+3)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
This side posts &#x03b4;(2n+3) to the other side with an authorization event that grants the guest access to the restored entry <code>pK0vR</code>.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">file/pK0vR<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
After the cache owner has granted access to the file, it must put the file content in the cache.
        </p>
      </li>
    </ol>
    <h3>Close session</h3>
    <p>
Delta sessions do not live forever. The next scenario shows how a session is closed.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1) on time.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(-2)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
This side decides to close the session. The HTTP client posts &#x03b4;(-2) to tell the other side the session should be closed. The delta message does not contain actions and it defines a zero lease time.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(-1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(-1) to acknowledge the session has been closed. This delta message also lacks actions.
        </p>
      </li>
    </ol>
    <p>
In the next scenario, the other side unexpectedly closes the session.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1).
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n+2)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n+2) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(-1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(-1) to inform the session has been closed.
        </p>
      </li>
    </ol>
    <p>
A closed session does not leave any traces. All attempts to access a session resource will fail after the session has been closed.
    </p>
    <h3>Dead session</h3>
    <p>
In the previous scenarios, a session is polled to determine how a problem might be fixed. A polling operation can of course also fail, demonstrated by the session in the next scenario.
    </p>
    <ol>
      <li>
      <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="bad-side">&perp;</span>
      <p>
The HTTP client sends a poll request, but it does not receive a suitable response. It does not matter whether the client does not receive a response at all, or whether the response reports a request failure.
      </p>
      </li>
      <li>
      <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="bad-side">&perp;</span>
      <p>
After waiting for at least three seconds, the HTTP client polls the session again. If it is still expecting a poll response from the previous attempt at this point, the unresponsive request is aborted.
      </p>
      </li>
      <li>
      <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="bad-side">&perp;</span>
      <p>
After another three seconds, the HTTP client polls the session for the last time. In this case, the situation remains bleak.
      </p>
      </li>
    </ol>
    <p>
If a session is unresponsive after three poll attempts, this side can safely conclude the session is dead. The delta protocol does not define how the HTTP client should react to a dead session. It's possible the client decides to die with the session. This kind of escalation behavior is outside the scope of the protocol.
    </p>
    <h3>Standard model</h3>
    <p>
Record type <code>Delta.Standard</code> describes a standard session model. The fields of the standard model control operations of the delta protocol. The models of application, process and terminal sessions are standard.
    </p>
    <p>
Field <code>serverLease</code> is the lease time in the next delta request. The server side can change the amount of lease time it gets from the client side in the next synchronization cycle. The server side overrules the client reaction to mutations and events with field <code>maximumDelay</code>. If the field is <code class="literal">null</code>, the client respects <code>@delay</code> annotations of record fields. The value <code>pause</code> prevents the client from buffering actions for too long. All mutations and events are reported within a short pause. The value <code>flush</code> instructs the client to buffer and flush all actions, including events with an infinite delay. Field <code>impatience</code> controls the use of ready and greedy messages in the session. If the field contains a number, the HTTP client should send a ready or greedy request if expiration of the current lease period is not expected within the specified number of seconds. If <code>plumbing</code> is set, files can be transferred through pipes. The session owns a cache with files if <code>caching</code> is set. A cache owner receives server events from field <code>download</code> when users access cached files. Client events from field <code>approve</code> grant and deny access to cached files.
    </p>
<pre>Delta.Standard: {
  serverLease: number,
  maximumDelay: Maybe("pause"_"flush"),
  impatience: number?,
  plumbing: Flag,
  caching: Flag,
  download: &lt;Delta.Access&gt; @event=server,
  approve: &lt;Delta.Authorization&gt; @event=client
}</pre>
    <h1>Welcome service</h1>
    <p>
The welcome service of an open mainframe serves the HTTP request of a browser that navigates to a welcome URL. The HTTP response is an HTML page with JavaScript code to initialize the runtime environment of a terminal. When the runtime environment has installed the application image, the terminal opens the session whose model describes a virtual user interface. The manifestation of the session model creates a real user interface that is presented in the browser. At this point, the terminal only needs the delta service to synchronize the virtual user interface with the mainframe. This chapter explains how web browsers become terminals.
    </p>
    <h2>Welcome URL</h2>
    <p>
Many web applications use cryptic URLs to store all kinds of state, e.g. session identifiers, application names and release versions. Although oma uses these ugly URLs internally as well, a welcome URL deserves special attention, because it involves a user experience. A user that bookmarks a welcome URL in a browser, expects to see a similar user interface when the bookmark is activated later on. The user is definitely not interested in expired sessions or version mismatches. The open mainframe architecture treats a welcome URL as a contract with users. Welcome URLs are first and foremost intended to offer a good user experience.
    </p>
    <p>
When a browser navigates to a welcome URL, the welcome service has to decide which deployed application is responsible for the user interface of a terminal. An application deployment subscribes itself to prefixes of welcome URLs that it wishes to associate with the application. The welcome service examines these subscriptions to link a welcome request to a deployed application. If the path of a welcome URL matches multiple subscriptions, the subscription of the most recently deployed application wins the conflict.
    </p>
    <p>
The subscription mechanism simplifies application management in oma. An application subscribes to welcome URLs that seem suitable for the particular type of deployment. Suppose a webshop application is deployed on a production site. This deployment welcomes terminals that visit URLs like <code>search/shirt</code>, which look meaningful to users. When a developer deploys the same webshop application on a development site, the deployment subscribes to welcome URLs that start with <code>_/app/AiQ9x/</code>. The ugliness does not disappoint a user in this case, because the developer is well aware the URLs belong to a temporary deployment.
    </p>
    <p>
Welcome URLs generally belong to one of the following categories.
    </p>
    <ul>
      <li>
        <p>domain entity</p>
        <p>
A welcome URL selects an entity from an application domain. The path of the URL starts with the domain name, followed by selection criteria to identify an entity, e.g. <code>shirt/53928</code>. Users expect these welcome URLs to last on production sites. They are convenient targets for bookmarks and for hyperlinks in HTML documents. 
        </p>
      </li>
      <li>
        <p>domain partition</p>
        <p>
The welcome URL of an entity in a flat domain does not convey implementation details about the backend. However, if the backend already partitions the domain in distinct chunks, e.g. geographically, the partition of an entity is an obvious URL prefix. For example, when a browser navigates to URL <code>us/search/shirt</code>, the terminal starts the US version of the webshop. The URL <code>de/suchen/hemd</code> starts the German version. These welcome URLs are expected to last on production sites, but the current partition scheme may not the best scheme in the future. Users are disappointed when a company changes welcome URLs after a major reorganization. 
        </p>
      </li>
      <li>
        <p>test release</p>
        <p>
Welcome URLs should last on production sites, but not necessarily on test sites. A user understands the welcome URL of a test application is not everlasting, although welcome URLs of common test releases, e.g. the last beta release, may be an exception. The user interface should clearly indicate the user is running a test version of the application to prevent confusion with the production site.
        </p>
      </li>
      <li>
        <p>temporary deployment</p>
        <p>
These welcome URLs are suitable for developers. They deploy and test many applications at cryptic, temporary welcome URLs. They may chat a welcome URL to another coworker to demonstrate a problem, but they also understand the specific backend application must still be deployed when the coworker navigates a browser to the URL.
        </p>
      </li>
    </ul>
    <p>
The welcome request of a terminal may pass through proxies before it arrives at a mainframe. Proxies rewrite URLs in HTTP requests, which is problematic for welcome requests, because the welcome URL is stored in the session model. A backend process may assume the browser of the terminal displays welcome URL <code>shirt/28471</code>, whereas the address bar of the browser actually displays <code>foo/shirt/28471</code>. The extra <code>foo/</code> prefix has been added by a proxy between the terminal and the mainframe. When a mainframe disallows the use of proxies, an offending browser is redirected to proper welcome URL. Redirection is also necessary if cookies are scoped to subdomains. The Same-Origin-Policy of browsers requires the welcome URL to stem from the same domain as the subdomains of new cookies. Production sites rely on subdomains to balance incoming HTTP traffic. If proxies are allowed between a terminal and a mainframe, the potential URL discrepancy between the address bar and the session model is a problem that terminals have to solve. The <dfn>welcome root</dfn> is an extra path prefix that is displayed in the address bar. Terminals strip the root prefix from welcome URLs in session models. Backend applications are not bothered by HTTP proxies.
    </p>
    <h2>Boot terminal</h2>
    <p>
When the welcome service knows which backend application is subscribed at a welcome URL, the service generates an HTML document for the browser. The HTML document should not contain sensitive information, e.g. a descriptive title of the domain entity, because the welcome service does not authenticate the welcome request. Everybody receives the same welcome response for a welcome URL, as long as the same application deployment remains subscribed at the given URL.
    </p>
    <p>
The generated HTML document is the first stage to boot a terminal. In the second stage, the terminal loads all assets it requires to present the real user interface of a backend process. In the final stage, the terminal opens the terminal session to obtain the model of the virtual user interface. The user however expects a visual clue that the application is running in the browser, before the terminal manifests the session model and presents the user interface in the last stage. This is especially important on mobile networks with significant latencies. The HTML document is treated as a splash screen that postpones the execution of JavaScript files. The browser first loads other resources that specify the initial appearance of the application. 
    </p>
    <p>
The next example shows a typical welcome response. After setting the base URL to match the mainframe root, relative to the welcome URL, the head section defines a link to a CSS style sheet. The head also inlines a small style sheet. The body section contains the <dfn>display element</dfn> (<code>#oma</code>) where the virtual user interface of the session model will be manifested in the DOM later on. Until that happens, the display element presents the splash content. The body section ends with several script tags, which initialize the runtime environment of the terminal. In the last inline script, the runtime environment installs the application image. One of the modules in the application image opens and/or restores the terminal session whose model is manifested in the DOM.
    </p>
<pre>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;base href="../../../"/&gt;
    &lt;link rel="stylesheet" href="_/pub/oma-runtime-browser/1.3.5/1/reset.css"/&gt;
    &lt;style&gt;&hellip;&lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="oma"&gt;&hellip;&lt;/div&gt;
    &lt;script src="_/pub/oma-runtime-system/1.3.2/bundle.js"&gt;&lt;/script&gt;
    &lt;script src="_/pub/oma-runtime-browser/1.3.5/bundle.js"&gt;&lt;/script&gt;
    &lt;script&gt;&hellip;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
    <h2>Open session</h2>
    <p>
The welcome service cannot tell whether a welcome request originates from a new or existing terminal. When a terminal boots, it must either open a new session or restore the old session. Terminals employ the session storage of HTML5 browsers to distinguish between these scenarios. The session storage survives a browser refresh. A terminal adds information to this storage after successfully opening a new terminal session to start an application. If a booting terminal retrieves this information, it knows how to restore the session. Otherwise it must open a new terminal session.
    </p>
    <p>
A terminal opens a session by dynamically adding a script tag whose URL parameters supply the welcome service with information about the terminal that cannot be derived from the welcome request.
    </p>
    <ul>
      <li>
        <p>
welcome URL (<code>ref</code>)
        </p>
        <p>
The URL of a welcome request does not include the hash fragment that is displayed in the address bar. The fragment is also missing from URLs in the <code>Referer</code> header of HTTP requests. An explicit script parameter with the full welcome URL corrects this omission.
        </p>
      </li>
      <li>
        <p>
backend application identity (<code>app</code>)
        </p>
        <p>
A welcome response contains code to load the image of a particular backend application, but a browser may use a cached welcome response after the application has been undeployed. A script parameter supplies the unique identity of the deployed application. When the welcome service is asked to open a new terminal session, it verifies the application is still deployed. If not, the terminal must fetch a fresh welcome response.
        </p>
      </li>
      <li>
        <p>
terminal identity (<code>tty</code>)
        </p>
        <p>
A script parameter specifies an optional identity, when the terminal opens a session to start an application. The welcome service needs this identity to distinguish between an existing terminal that starts a new application, and a new terminal that starts the first application.
        </p>
      </li>
    </ul>
    <p>
The resource to open a terminal session is located at <code>_/start</code>, relative from the base URL. A browser sends an HTTP request with script parameters to obtain the JavaScript source of a script. The corresponding HTTP response may issue cookies with <code>Set-Cookie</code> headers. The welcome service associates several cookies with a terminal. The <dfn>device identity</dfn> is a persistent cookie that tracks the browser of a terminal. The <dfn>guest identity</dfn> and <dfn>guest ticket</dfn> are transient cookies that authenticate the user of a terminal. The welcome service issues the guest cookies once, but the device cookie is renewed whenever guest cookies are issued. The combination of guest identity and ticket proves terminals belong to a unique person, although the welcome service does not know what this person is allowed to do.
    </p>
    <p>
The welcome service protects confidentiality of guest tickets, because they resemble temporary passwords. The service does not store plain guest tickets to limit the damage of a compromised guest administration. When the service issues guest cookies, it computes and stores a hash-based authentication code of the guest identity with a secret ticket. An HTTP request is considered authentic if the supplied ticket cookie reproduces the hash code that was stored with the guest identity.
    </p>
    <p>
When a user navigates the first terminal to a welcome URL on a mainframe, the welcome service issues the device and guest cookies of the terminal. When a second terminal is opened in a new browser window but still on the same mainframe, both terminals share their device and guest cookies. This improves the user experience, because the user is not forced to login twice. The guest cookies are automatically removed upon closing all browser windows. This ensures the user does not leave any traces behind that could be abused to steal credentials.
    </p>
    <h2>Restore session</h2>
    <p>
The last stage of a booting terminal restores the session and manifests the model to present a real user interface in the browser. If the browser is still loading the script to open the session, the terminal must wait for this script to complete, because the script persists the location of the terminal session.
    </p>
    <p>
A booting terminal retrieves its session URL from the HTML5 session storage. Armed with the URL, the terminal sends an HTTP request to get a JSON dump of the session. The dump reveals the complete state of a virtual user interface. If the terminal is restoring an existing session, the user interface continues in the state where the terminal left the application the last time. If the terminal has just opened a new session, the virtual user interface is in an indeterminate state. When the backend process produces delta response &#x03b4;(0) with an initial virtual user interface, it doesn't know whether the terminal device is a mobile smartphone with touch support, a laptop with keyboard and mouse support, or some other device. Session values whose manifestations rely on specific device features must appear in delta response &#x03b4;(2) or later, because a terminal reports supported device features in delta request &#x03b4;(1).
    </p>
    <p>
When the session dump is available, the terminal waits for the installation of the application image to finish. This ensures the terminal has loaded all modules, which are required to manifest the session model. Module configurations bind data types to manifestation classes. If the dynamic type of a session value is bound to a manifestation class, an object of this class is created. The new manifestation object implements the intended behavior of the session value in the browser environment, e.g. a real slider control in the browser DOM that synchronizes a virtual slider in the session.
    </p>
    <h1>Deploy service</h1>
    <p>
A backend application contacts the deploy service of an open mainframe to enable frontend terminals to start the application. An HTTP client deploys a backend application by posting a request to resource <code>_/deploy</code>. The HTTP response of a successful deployment contains a string with the identity of a deployed application. Otherwise the HTTP status code of the deploy response indicates an error.
    </p>
    <h2>Light deployment</h2>
    </p>
The body of a deploy request contains the compact JSON representation of an <code>App.Deploy</code> value if the deployment is light. Field <code>bundles</code> maps bundle names to bundle versions. Field <code>welcomes</code> lists the patterns of welcome URLs to which the application wants to subscribe. Field <code>rooted</code> affects the welcome root of terminals that start the application. The minimum byte size of the file cache is optionally specified in field <code>cacheSize</code>. Optional field <code>splash</code> defines the initial appearance in a browser when a terminal starts the application.
    </p>
<pre>App.Deploy: {
  bundles: &lt;string&gt;,
  welcomes: [string],
  rooted: Flag,
  cacheSize: number?,
  splash: App.Splash?
}</pre>
    <p>
Field <code>asset</code> of an <code>App.Splash</code> value contains the URL of an HTML asset that will be embedded in the display element of a booting terminal. Field <code>sheets</code> specifies a list of style sheets. Field <code>asset</code> of an <code>App.Sheet</code> value contains the URL of a CSS asset. If field <code>inlined</code> is set, the HTML document of a booting terminal inlines the style sheet in the head section. Otherwise the head section includes a link to the style sheet.
    </p>
<pre>App.Splash: {
  asset: string,
  sheets: [App.Sheet]
}
App.Sheet: {
  asset: string,
  inlined: Flag
}</pre>
    <h2>Heavy deployment</h2>
    <p>
The deploy request of a heavy deployment has a <code>multipart/form-data</code> body with two entries. The entry <code>deploy</code> encodes the compact JSON representation of an <code>App.Deploy</code> value. The entry <code>source</code> is a compressed archive whose modules with source assets should be compiled and published in a directory on a web server. The next chapter explains how the library service compiles and publishes assets of modules. The compiled assets are published at <code>_/app/<span class="variable">id</span>/_/pub</code> in the frontend where <span class="variable">id</span> is the application identity.
    </p>
    <p>
When a heavy deployment uploads an archive with a module that is also contained in a bundle of the <code>App.Deploy</code> value, the module from the heavy deployment ends up in the application image. Frontend developers use this feature to replace one or more modules in an existing application image. They test these alternative modules in browser environments until they are satisfied with the result. Once they have published the modules in library bundles, a heavy deployment is no longer necessary, because the new bundle versions can be referenced from light deployments.
    </p>
    <h2>Application session</h2>
    <p>
An application session is located at <code>_/mount/<span class="variable">id</span></code> in the backend where <span class="variable">id</span> is the identity of a deployed application. A backend application restores the session model from a session dump after a deploy response has revealed the application identity. The model of an application session is an <code>App.Model</code> value. Field <code>image</code> conveys the application image with bundled modules that terminals can load. Field <code>groups</code> counts the number of group sessions in the application. A client event from field <code>resize</code> specifies how many group sessions the application would like to add. A negative amount indicates the application wants to remove group sessions.
     </p>
<pre>App.Model: App.Group + {
  image: App.Image,
  groups: number,
  resize: number @event=client
}</pre>
    <p>
A <dfn>process group</dfn> multiplexes the synchronization of backend processes. A group session is a forward delta session, located at <code>_/mount/<span class="variable">id</span>/<span class="variable">group</span></code> where <span class="variable">id</span> is an application identity and <span class="variable">group</span> is an ordinal group index, i.e. group <code>1</code> is the first, group <code>2</code> is the second, etc. Group <code>0</code> is special, because the session of group <code>0</code> is the application session. Group <code>0</code> represents the application where new processes are born. The model of a group session is an <code>App.Group</code> value. The dictionary in field <code>members</code> maps identities of all processes in the group to values of type <code>App.Launch</code>. A client event from field <code>relocate</code> contains a dictionary that maps process identities to group indices. A group can move a member to another group. If the value in the dictionary of a relocation event is <code class="literal">null</code>, the member should be detached. The synchronization of a detached process is not multiplexed. Field <code>request</code> is the origin of a server event with delta requests from terminals. The keys in the dictionary of the event identify members whose process sessions are paired with terminal sessions. Field <code>respond</code> is the origin of a client event with delta responses from members. Fields <code>request</code> and <code>respond</code> multiplex the delta messages of group members over a single HTTP connection. Apart from the <code>do</code> resource for model synchronization, the other HTTP resources of a process session, e.g. <code>poll</code> to query the session status, are not affected by the process group.
    </p>
<pre>App.Group: Delta.Standard + {
  members: &lt;App.Launch&gt;,
  relocate: &lt;number?&gt; @event=client,
  request: &lt;Delta.Message&gt; @event=server,
  respond: &lt;Delta.Message&gt; @event=client
}</pre>
    <p>
When a terminal starts an application, the backend application launches a new process. Field <code>guest</code> of an <code>App.Launch</code> value identifies the authenticated guest that starts the application. The terminal identity is contained in field <code>terminal</code>. The URL in field <code>welcome</code> is the welcome URL of the terminal that triggered the launch.
    </p>
<pre>App.Launch: {
  guest: string,
  terminal: string,
  welcome: string
}</pre>
    <h2>Application image</h2>
    <p>
An application image lists all modules of an application. A booting terminal installs an image from the compact JSON representation of an <code>App.Image</code> value. The application identity is specified in field <code>app</code>. Field <code>bundles</code> is a dictionary that maps bundle names to URLs where bundles are published. Field <code>modules</code> maps module names to record values of type <code>App.Module</code>.
    </p>
<pre>App.Image: {
  app: string,
  bundles: &lt;string&gt;,
  modules: &lt;App.Module&gt;
}</pre>
    <p>
Modules serve many purposes in oma. They contain class definitions, data type definitions, binary assets, etc. An <code>App.Module</code> value concentrates on the information that is necessary to decide if and when a terminal should load a module. Field <code>bundle</code> identifies the bundle that publishes the module. Field <code>index</code> is the ordinal index of the module.  The location of a module is derived from the URL of the bundle and the ordinal index of the module in this bundle. If version 2.3.7 of bundle <code>foo</code> is published at <code>_/pub/foo/2.3.7</code>, the first module is located at <code>_/pub/foo/2.3.7/1</code>. Field <code>depends</code> lists names of modules. A module must be loaded after the dependencies have been loaded. Cyclic dependencies are not allowed. Field <code>conditional</code> indicates a module might not load, even though all dependencies have been successfully loaded. A conditional module may require support for a particular device feature, e.g. audio playback, which the runtime environment does not offer.
    </p>
<pre>App.Module: {
  bundle: string,
  index: number,
  depends: [string],
  conditional: Flag
}</pre>
    <h2>Process session</h2>
    <p>
A process session is located at <code>_/proc/<span class="variable">id</span></code> in the backend where <span class="variable">id</span> is a process identity. A process reveals its identity when a new member is added to group <code>0</code> in the application model.
    </p>
<pre>UI.Model: Delta.Standard + {
  features: &lt;Any&gt; @data=client,
  title: string,
  favicon: string,
  navigation: string @data=client @delay=block,
  visible: boolean @data=client @delay=block,
  resolution: UI.Resolution @data=client,
  viewport: UI.Pixel @data=client,
  ui: UI.Widget,
  refresh: boolean @event=server,
  redirect: UI.Redirect @event=server
}
UI.Resolution: {
  colorDepth: number,
  pixel: UI.Pixel,
  effective: UI.Pixel
}
UI.Pixel: {
  height: number,
  width: number
}
UI.Redirect: {
  welcome: string,
  hard: Flag
}</pre>
    <h1>Library service</h1>
    <h1>Diagnostics service</h1>
    <h1>Virtual user interface</h1>
    <p>
The virtual user interface of oma describes basic features that any real user interface in a terminal must be able to support. This boils down to HTML features, because terminals are web browsers. However, HTML was not designed to construct consistent user interfaces. HTML is very rich and expressive, which is an invitation for developers to tweak the HTML markup of user intefaces, until they are pixel-precise replicas of mock-ups. In theory, CSS is a powerful instrument to separate styling from HTML markup. The harsh reality is that the amount of CSS classes, rules and properties in web applications quickly explodes to incomprehensible proportions. If developers are not careful, CSS preprocessors only worsen the situation with more bloated style sheets. The philosophy of CSS envisions cooperation between team members to develop a solid strategy, but CSS is too often an afterthought in projects.
    </p>
    <p>
The virtual user interface borrows heavily from HTML and CSS. It is an attempt to take the good parts of these technologies and to drop the smelly parts. The final result, discussed in this chapter, should improve cooperation between all team disciplines that are involved in the construction of user interfaces, both virtual and real.
    </p>
    <h2>Standard toolkit</h2>
    <p>
A virtual user interface is built from a tree of widgets. A <dfn>widget</dfn> is a user interface control with a clear purpose. Widgets are defined in toolkits, and the standard toolkit defines the minimal set of widgets that work on all terminal devices.
    </p>
    <h3>Widget</h3>
    <p>
A virtual widget is a <code>UI.Widget</code> record value. When <code>hidden</code> is truthy, the widget should not be manifested in the browser DOM. If a DOM manifestation already exists, it must either be removed or its CSS <code>display</code> property must be set to <code>none</code>. Field <code>style</code> contains <code class="literal">null</code>, a style class name, or a list with style class names. These names are mapped to one or more CSS class names in the DOM. Optional numeric field <code>index</code> determines the presentation order of a widget when it's part of a dictionary composition.
    </p>
<pre>UI.Widget: {
  hidden: Flag,
  style: UI.Style?,
  index: number?
}
UI.Style: string | [string]</pre>
    <p>
Virtual widgets roughly fall into four categories, although a concrete widget type may combine features from several categories. A <dfn>layout widget</dfn> specifies a layout strategy for optional child widgets. The composition of children is a list or dictionary with widget values. A <dfn>decorator widget</dfn> adds features to another widget, the <code>subject</code>. An <dfn>output widget</dfn>, that displays a text or image in a virtual user interface, has a symbolic identifier for localization purposes. An <dfn>input widget</dfn> captures real user interactions and translates them to delta actions on a virtual widget, but only when it's enabled. An interactive input widget may need exclusive focus. An unchained widget is dropped from the list of  focusable widgets in the DOM, which a user can traverse, for example with <code>tab</code> and <code>alt-tab</code> keys on terminal devices with keyboards. When the user presses a key on the keyboard, the input widget with focus generates a client event.
    </p>
<pre>UI.Layout(T=UI.Widget): UI.Widget + {
  widgets: Maybe(UI.Composition(T))
}
UI.Composition(T=UI.Widget): [T] | &lt;T&gt;
UI.Decorator(T=UI.Widget): UI.Widget + {
  subject: T?
}
UI.Output: UI.Widget + {
  symbol: string?
}
UI.Input: UI.Widget + {
  disabled: Flag,
  unchained: Flag,
  focus: boolean @event=client @delay=forever,
  grab: none @event=server,
  press: UI.Event.Keypress @event=client @delay=forever
}</pre>
    <h3>Layout</h3>
    <p>
The 2D area that a virtual widget occupies in a user interface, is intrinsically driven by the content and styling of the widget, except for sizeable widgets with an explicit height or width. A sizeable widget without a height or width automatically grows and shrinks to accommodate for its content. Otherwise, the size of a sizeable widget is either fixed at a CSS length, or proportional to the size of the parent widget.
    </p>
<pre>UI.Sizeable: {
  height: UI.Size?,
  width: UI.Size?
}
UI.Size: UI.Length | number
UI.Length: {
  n: number,
  u: "ch"_"em"_"ex"_"px"_"rem"
}</pre>
    <p>
A <dfn>widget frame</dfn> is a sizeable display surface for a child subject. A <dfn>metal frame</dfn> is a frame that is also a layout surface for child magnets. A <dfn>magnet frame</dfn> has an absolute position, relative to the top left corner of the metallic parent. A numeric top or left is proportional to the size of the parent. A negative magnet height or width, whether fixed-length or proportional, is subtracted from the distance to the opposite side of the metallic parent. For example, if <code>width</code> is minus ten percent (<code>-0.1</code>), the right side of a magnet is positioned at ninety percent of the parent's width. A horizontal or vertical translation positions the magnet at its final location. A numeric translation is proportional to the size of the magnet.
    </p>
<pre>UI.Frame: UI.Sizeable + UI.Decorator
UI.Metal: UI.Frame + UI.Layout(UI.Magnet)
UI.Magnet: UI.Metal + {
  left: UI.Size?, top: UI.Size?,
  translationX: UI.Size?, translationY: UI.Size?
}</pre>
    <p>
The items in a sizeable <dfn>widget list</dfn> either flow horizontally in rows or vertically in columns. The layout of list items is controlled with CSS flexbox features. Unless specified differently, items flow from left to right, they wrap in multiple rows from top to bottom, they are left-aligned in a row, they stretch to fit the row height, and when there are multiple rows, the rows stretch to fit the list height.
    </p>
<pre>UI.List: UI.Sizeable + UI.Layout(UI.Item) + {
  direction: UI.Flow.Direction?,
  cut: UI.Flow.Cut?,
  justification: UI.Flow.Justification?,
  itemAlignment: UI.Flow.ItemAlignment?,
  contentAlignment: UI.Flow.ContentAlignment?
}</pre>
    <p>
Items in a list flow from right to left in a <code>rowReverse</code> direction, from top to bottom in a <code>column</code> direction, and from bottom to top in a <code>columnReverse</code> direction.
    </p>
<pre>UI.Flow.Direction: "rowReverse"_"column"_"columnReverse"</pre>
    <p>
A list cuts the content to wrap items in multiple rows or columns by default, unless overruled with <code>never</code>. A list that does not cut, will overflow horizontally or vertically if there are too many items to fit in one row or column. When a list cuts the content in the <code>reverse</code> direction, multiple rows or columns are positioned in reverse order. For example, a list with row direction that needs two rows to layout the content, contains the last items in the top row and the first items in the bottom row.
    </p>
<pre>UI.Flow.Cut: "never"_"reverse"</pre>
    <p>
Field <code>justification</code> controls how a list distributes empty space between items on the direction axis. Items in a list are left-aligned by default in a row direction, right-aligned with <code>opposite</code>, horizontally centered with <code>center</code> and evenly distributed in a row with <code>between</code> and <code>around</code>.
    </p>
<pre>UI.Flow.Justification: "opposite"_"center"_"between"_"around"</pre>
    <p>
Field <code>itemAlignment</code> specifies alignment of items, perpendicular to the direction axis, i.e. vertical alignment of row items or horizontal alignment of column items. By default, items are not aligned, stretching to row height or column width. Otherwise, they are compactly aligned with <code>start</code>, <code>end</code>, <code>center</code> or <code>baseline</code>.
    </p>
<pre>UI.Flow.ItemAlignment: "start"_"end"_"center"_"baseline"</pre>
    <p>
Field <code>contentAlignment</code> specifies how a list distributes empty space between multiple rows or columns. It is ignored when the list has one row or column. By default, rows stretch to cover the list height and columns stretch to cover the list width. Otherwise, they are compactly aligned with <code>start</code>, <code>end</code>, <code>center</code>, <code>between</code> or <code>around</code>.
    </p>
<pre>UI.Flow.ContentAlignment: "start"_"end"_"center"_"between"_"around"</pre>
    <p>
A <dfn>list item</dfn> decorates a subject that flows in a list layout. Optional fields <code>grows</code>, <code>shrinks</code> and <code>basis</code> specify flexibility of an individual list item. Perpendicular alignment of a list item is overruled with field <code>alignment</code>.
    </p>
<pre>UI.Item: UI.Decorator + {
  grows: number?,
  shrinks: number?,
  basis: UI.Size?,
  alignment: UI.Flow.Alignment?
}
UI.Flow.Alignment: "stretch" | UI.Flow.ItemAlignment</pre>
    <h3>Output</h3>
    <p>
A <dfn>text widget</dfn> displays lines of text inside a virtual user interface. The bounding box of the widget grows and shrinks to wrap the text, unless style classes restrict the width of the box and also prevent line wrapping.
    </p>
<pre>UI.Text: UI.Output + {
  line: Text?
}</pre>
    <p>
An <dfn>image widget</dfn> adds graphics to a virtual user interface. Field <code>asset</code> contains the URL where the binary asset is located.
    </p>
<pre>UI.Image: UI.Output + {
  asset: string?
}</pre>
    <p>
An <dfn>icon widget</dfn> resembles a list with an image and text widget, whose direction can be specified. An icon in the default row direction flows the image and text from left to right. The image and text are compactly aligned from the start of the direction axis, and they are centered, perpendicular to this axis.
    </p>
<pre>UI.Icon: UI.Image + UI.Text + {
  direction: UI.Flow.Direction?
}</pre>
    <h3>Input</h3>
    <p>
A <dfn>scroll input</dfn> pins a viewport frame to the display surface of the decorated subject. The viewport selects the visible portion when the display surface is too large. Horizontal and vertical scroll offsets are proportional to size differences. For example, if <code>scrollY</code> is <code>0</code>, the top of the viewport aligns with the top of the surface. If <code>scrollY</code> is <code>1</code>, the bottom of the viewport aligns with the bottom of the surface.
    </p>
<pre>UI.Scroll: UI.Input + UI.Frame + {
  scrollX: number? @data=both @delay=flush,
  scrollY: number? @data=both @delay=flush
}</pre>
    <p>
A <dfn>button widget</dfn> decorates a subject widget with a click feature to activate or select the subject. Most buttons decorate an output widget, e.g. an icon. Although it's possible to nest another interactive widget inside a button, it should be avoided, because it looks and feels confusing.
    </p>
<pre>UI.Button: UI.Input + UI.Decorator + {
  click: UI.Event.Click @event=client @delay=forever
}</pre>
    <p>
A <dfn>navigation button</dfn> is a hyperlink that navigates the terminal to a new URL, when the user activates the hyperlink. Field <code>location</code> contains the URL.
    </p>
<pre>UI.NavButton: UI.Button + {
  location: string
}</pre>
    <p>
A <dfn>command button</dfn> initiates a blocking operation. The user interface is unresponsive after activating the button, until the server side has processed the click event.
    </p>
<pre>UI.CmdButton: UI.Button + {
  click: UI.Event.Click @event=client @delay=block
}</pre>
    <p>
A user interacts with a <dfn>selection widget</dfn> to make a choice. A <dfn>choice widget</dfn> is a special button that is always unchained. The parent selection determines how focus programmatically switches between choice buttons, for example with arrow keys on a keyboard.
    </p>
<pre>UI.Selection: UI.Input + UI.Layout(UI.Choice)
UI.Choice: UI.Button + {
  unchained: void,
  selected: Flag
}</pre>
    <p>
A <dfn>radio list</dfn> selects at most one radio button. Radio buttons cannot be deselected by the user. The list automatically deselects a radio button when the user selects another button from the list. The default direction of a radio list flows the buttons from left to right in a row. 
    </p>
<pre>UI.RadioList: UI.Selection + {
  direction: UI.Flow.Direction?
}</pre>
    <p>
A <dfn>check list</dfn> displays zero or more checkboxes. The direction specifies how checkboxes flow in the check list, similar to a radio list.
    </p>
<pre>UI.CheckList: UI.Selection + {
  direction: UI.Flow.Direction?
}</pre>
    <p>
A <dfn>cycle button</dfn> decorates the current choice. Although a cycle button appears to nest buttons, which is generally a bad idea, only one choice is ever visible. When the user presses the button, the decorated subject is replaced by the next choice from the selection. The behavior of cycle buttons is similar to how radio lists behave, but cycle buttons take up less space in the user interface. They are convenient controls if there are a few obvious choices.
    </p>
<pre>UI.CycleButton: UI.Selection + UI.Button</pre>
    <h2>Style classes</h2>
    <p>
Style classes serve different purposes in a virtual user interface. A <dfn>skin class</dfn> defines essential styling of virtual widgets, e.g. absolute CSS positioning of magnet frames. The skin of a widget is not affected by the look-and-feel of an application. Themes control the appearance of widgets with a <dfn>status class</dfn>. A <code>UI.Widget</code> value specifies server status classes in field <code>style</code>. Client status classes are dynamically added to a widget when the widget is in the right state on the client side. For example, status class <code>Foreground</code> is added to a widget that has focus, or that contains a child with the foreground status. Client status classes are similar to pseudo-classes in CSS.
    </p>
    <p>
CSS supports property inheritance from a parent to a child element in the DOM, but it does not support class inheritance. A style class cannot inherit properties from one or more superclasses. CSS preprocessors solve this problem with mixins that copy style properties to a class, but oma approaches the problem from a different angle. When a terminal computes the DOM representation of a virtual user interface, the top level DOM element of a widget specifies inherited style classes. The DOM element of a widget with style class <code>Foo</code> includes both <code>Foo</code> and <code>Bar</code>, if <code>Foo</code> is a subclass of <code>Bar</code>. The inclusion of inherited classes is transitive. If <code>Bar</code> is a subclass of <code>Baz</code>, the DOM element includes <code>Foo</code>, <code>Bar</code> and <code>Baz</code>.
    </p>
    <p>
Style class inheritance assumes the CSS property definitions of a subclass appear in the HTML document after the superclasses have been defined. This is required for property specialization in subclasses. The last definition of a CSS property in the document wins when conflicting rules have equal specificity. Style classes are defined in JavaScript to simplify the processing of style classes. The JavaScript definitions of style classes are evaluated to calculate a suitable definition order for CSS selectors and properties in a style sheet. Developers should not be concerned with the definition order of style classes.
    </p>
    <h1>Appendix</h1>
    <h2>HTTP</h2>
    <h3><span class="variable">welcome</span></h3>
    <p>
If a URL does not start with an underscore and a slash, it is a treated as a welcome URL. The URL is matched against the subscriptions of rooted deployments to find the appropriate application.
    </p>
    <h3>_/deploy</h3>
    <p>
Deploy a backend application. Light deployment posts a JSON object. Heavy deployment uploads JSON object and a source archive.
    </p>
    <h3>_/start</h3>
    <p>
Open terminal session and start application in browser. The GET response contains JavaScript code to persist info about terminal session in the browser, using HTML5 session storage.
    </p>
    <h3>_/publish</h3>
    <p>
Publish new library bundle. Assets in uploaded source archive are compiled and copied to directory on a web server.
    </p>
    <h3>_/pub/<span class="variable">bundle</span>/<span class="variable">version</span>/bundle.js</h3>
    <p>
JavaScript loader to install particular version of the bundle.
    </p>
    <h3>_/pub/<span class="variable">bundle</span>/<span class="variable">version</span>/<span class="variable">module</span>/&hellip;</h3>
    <p>
Access compiled asset from a module. The module is identified by an ordinal index inside the versioned bundle. Path remainder locates asset inside module.
    </p>
    <h3>_/mount/<span class="variable">app-id</span>/<span class="variable">operation</span></h3>
    <p>
Initiate delta session operation in an application session.
    </p>
    <h3>_/mount/<span class="variable">app-id</span>/<span class="variable">group</span>/<span class="variable">operation</span></h3>
    <p>
Initiate delta session operation in a group session. The group is identified by an ordinal index.
    </p>
    <h3>_/proc/<span class="variable">proc-id</span>/<span class="variable">operation</span></h3>
    <p>
Initiate delta session operation in a process session.
    </p>
    <h3>_/tty/<span class="variable">tty-id</span>/<span class="variable">app-id</span>/<span class="variable">operation</span></h3>
    <p>
Initiate delta session operation in a terminal session.
    </p>
    <h3>_/app/<span class="variable">app-id</span>/<span class="variable">welcome</span></h3>
    <p>
Welcome URL for temporary deployment of a backend application.
    </p>
    <h3>_/app/<span class="variable">app-id</span>/_/file/<span class="variable">name</span></h3>
    <p>
Get file from application cache. A terminal is authenticated and authorized before it can download a cached file.
    </p>
    <h3>_/app/<span class="variable">app-id</span>/_/pub/<span class="variable">module</span>/&hellip;</h3>
    <p>
Access compiled asset from module in heavy deployment.
    </p>
  </body>
</html>
