<!DOCTYPE html>
<html>
  <head>
    <title>The open mainframe architecture</title>
    <style>
html {
  font-family: serif;
  font-size: 16px;
}
body {
  padding: 10px 2%;
}
code {
  white-space: pre;
}
p {
  margin: 0.25em 0;
  text-align: justify;
}
pre {
  margin-left: 0.5em;
}
.inline {
  display: inline-block;
}
.comment {
  color: green;
  font-style: italic;
}
.pattern {
  font-weight: bold;
}
.variable {
  font-style: italic;
}
.variable::before {
  content: "\00AB";
}
.variable::after {
  content: "\00BB";
}
.figure {
  padding: 1em;
  text-align: center;
}
.keyword {
  color: blue;
}
.literal {
  color: brown;
  white-space: pre;
}
.boundary {
  border-style: dashed;
  border-width: 0;
  text-align: right;
}
.boundary span {
  font-style: italic;
  margin-right: -4em;
}
.backend {
  border-bottom-width: thin;
}
.frontend {
  border-top-width: thin;
}
.http {
  border: solid thin;
  box-shadow: 5px 5px 4px #666;
}
.http sub {
  font-size: 60%;
}
.client {
  border-radius: 10px;
  padding: 4px;
  display: inline-block;
}
.server {
  padding: 12px;
  display: inline-block;
}
.entity-isolated {
  margin: 0 1em;
}
.entity-middle {
  margin: 0 0.25em;
}
.entity-right {
  margin: 0 1em 0 0.25em;
}
.entity-left {
  margin: 0 0.25em 0 1em;
}
.network-stack {
  box-sizing: border-box;
  border-spacing: 0;
  border-collapse: collapse;
  margin: 1em auto;
  width: 20em;
}
.network-stack td {
  text-align: center;
}
.layer td {
  padding: 0.25em;
  border-width: thin;
  border-left-width: 0;
  border-right-width: 0;
}
.firewall.layer td {
  border-style: dotted;
}
.network.layer td {
  border-style: solid;
}
.network-flow {
  font-size: 0.5em;
}
.layer td.network-separator {
  border-bottom-style: none;
  border-top-style: none;
}
.rule-conclusion, .rule-condition {
  display: inline-block;
}
.rule-condition {
  margin-left: 0.5em;
  margin-right: 2em;
}
.rule-condition:after {
  content: '\21d2';
  display: inline-block;
  margin-left: 2em;
}
.delta-side, .delta-message, .bad-side {
  display: inline-block;
  text-align: center;
}
.delta-side, .bad-side {
  width: 3em;
}
.delta-side {
  border: solid thin;
  box-shadow: 2px 2px 3px #666;
  padding: 0.25em 0;
}
.delta-message {
  line-height: 90%;
  margin: 0 1em;
  vertical-align: middle;
  width: 6em;
}
    </style>      
  </head>
  <body>
    <h1>Introduction</h1>
    <p>
The open mainframe architecture (oma) is an application architecture that revives old ideas. A terminal presents the user interface of a remote process. A mainframe traditionally runs these processes for connected terminals, but in oma, a process runs autonomously in the backend tier. A backend application must be deployed on an open mainframe to enable terminals to start the application. Terminals populate the frontend tier. An open mainframe in the middle acts as a router between the frontend and backend. When a terminal starts a deployed application, the application creates a backend process. The new process is a running instance of the backend application, which handles user interactions that the terminal reports.
    </p>
    <p>
Backend applications and their processes are not concerned with presentation technologies for user interfaces. Frontend terminals don't care about application logic to process user interactions. Traditional and open mainframes provide the same separation of presentation and application concerns. Although oma adds an extra middle tier to improve scalability, this does not affect the primary separation of concerns. Unlike traditional mainframes with proprietary technologies, oma relies on open web standards. A frontend terminal is a modern HTML browser that presents the user interface of a backend process. This process is an HTTP client that updates the user interface when the terminal reports user interactions. A backend application is an HTTP client that manages the deployment on an open mainframe.
    </p>
    <div class="figure">
      <div class="inline">
        <div class="inline entity-isolated">
          <span class="http client">term<sub>1</sub></span><br/>
          &dArr;<br/>
        </div>
        <div class="inline entity-isolated">
          <span class="http client">term<sub>2</sub></span><br/>
          &dArr;<br/>
        </div>
        <div class="inline entity-isolated">
          <span class="http client">term<sub>3</sub></span><br/>
          &dArr;<br/>
        </div>
        <div class="boundary frontend"><span>frontend boundary</span></div>
        <span class="inline http server">open<br/>mainframe</span><br/>
        <div class="boundary backend"><span>backend boundary</span></div>
        <div class="inline entity-left">
          &dArr;<br/>
          <span class="http client">proc<sub>1.1</sub></span><br/>
        </div>
        <div class="inline entity-middle">
          &uArr;<br/>
          <span class="http client">app<sub>1</sub></span><br/>
        </div>
        <div class="inline entity-right">
          &dArr;<br/>
          <span class="http client">proc<sub>1.2</sub></span><br/>
        </div>
        <div class="inline entity-left">
          &uArr;<br/>
          <span class="http client">app<sub>2</sub></span><br/>
        </div>
        <div class="inline entity-right">
          &dArr;<br/>
          <span class="http client">proc<sub>2.1</sub></span><br/>
        </div>
        <div class="inline entity-isolated">
          &uArr;<br/>
          <span class="http client">app<sub>3</sub></span><br/>
        </div>
      </div>
    </div>
    <p>
An open mainframe implements the following web services on frontend and backend networks.
    </p>
    <ul>
      <li>
        <p>
delta service
        </p>
        <p>
This service manages delta sessions for HTTP clients. The arrows in the figure are delta sessions. A <dfn>delta session</dfn> synchronizes a JSON model that both sides of the session share. The client side sends a delta request with actions on the model. A delta action is either a mutation that modifies the model, or an event that signals an incident in the model. The server side replies with a delta response whose actions on the model reflect the side effects of processing the previous request. The sequential exchange of delta messages continues, until one of the sides closes the session.
        </p>
        <p>
The direction of an arrow depicts the flow of delta requests. Terminal and application sessions are <dfn>forward sessions</dfn>. Terminals and applications are HTTP clients that fulfil the client role in delta sessions. Processes are also HTTP clients, but they play the server role in delta sessions. Process sessions are <dfn>reverse sessions</dfn>.
        </p>
      </li>
      <li>
        <p>
welcome service
        </p>
        <p>
The welcome service establishes contact between a terminal and an open mainframe. When a browser navigates to a <dfn>welcome URL</dfn>, it becomes a terminal that requests the welcome service to start an application. The service finds the deployed application that is responsible for the welcome request. This application is instructed to create a new process, which computes the initial model of a virtual user interface. The terminal subsequently presents a real version of this user interface in the web browser.
        </p>
        <p>
The new process session in the backend is paired with the new terminal session in the frontend. A <dfn>session pair</dfn> synchronizes the same model in opposite directions. The terminal session controls the client side of the model whereas the process session controls the server side. The open mainframe only has to relay delta messages between the client and server side of a session pair.
        </p>
      </li>
      <li>
        <p>
deploy service
        </p>
        <p>
This service deploys backend applications on an open mainframe. The service receives an HTTP POST request with a meticulous description of an application deployment. This description is consulted by the mainframe when it welcomes a terminal.
        </p>
        <p>
The service supports two forms of deployment. In a <dfn>light deployment</dfn>, a backend application is fully described by a JSON object in the deploy request. In a <dfn>heavy deployment</dfn>, an application uploads a source archive that accompanies a JSON object in the deploy request. The assets in the archive are compiled and published in a directory on a web server. Both forms of deployment eventually create a new application session. The mainframe employs this session to instruct the backend application to create new processes, when terminals start the application.
        </p>
      </li>
      <li>
        <p>
library service
        </p>
        <p>
This service resembles a public library where anyone can read books, known as bundles in oma terminology. A <dfn>bundle</dfn> publishes the compiled assets of a source archive in a directory on a web server. All terminals load standard library bundles that initialize a JavaScript runtime environment in the browser.
        </p>
        <p>
Bundles are distribution units for modules. When a terminal needs a module from a bundle, it loads all modules of the bundle in one download, improving startup times of applications. If a bundle is like a book, a module is like a chapter in a book. A <dfn>module</dfn> is a logically cohesive set of assets with a well-defined purpose. A modular organization with clear boundaries between modules reduces complexity of asset management. Developers should generally not care about the bundles in which their modules are distributed. This flexibility promotes the development of many small modules that specify their dependencies on other modules.
        </p>
      </li>
      <li>
        <p>
diagnostics service
        </p>
        <p>
Components in a perfect architecture are black boxes with hidden implementations, but the diagnostics service in oma offers a peek inside to expose some inner workings. This service supplies metrics about the performance and load of an open mainframe, e.g. number of connected terminals, deployed applications and exchanged delta messages. This operational data allows HTTP clients to monitor the health of a mainframe. Diagnostics clients should detect minor issues before they turn into major problems.
        </p>
      </li>
    </ul>
    <p>
The open mainframe architecture leverages the success of HTTP. Common problems like HTTPS encryption, serving static files and load balancing have already been solved in numerous hardware and software products. The challenge is to encorporate these products in the infrastructure of oma as smoothly as possible. Reliance on HTTP for all communication between tiers ensures HTTP-based products work equally well in both frontend and backend networks.
    </p>
    <p>
Browsers are converging towards an impressive set of web standards. HTML5 standards cover a wide range a devices, from mobile smartphones to desktop computers. Backend applications are able to optimize the user experience for different types of devices, because every backend process handles user interactions for a particular terminal device. The open mainframe architecture does not unify terminal devices. It is up to applications to exploit specific device capabilities in user interfaces. 
    </p>
    <p>
Despite a problematic childhood, JavaScript has matured reasonably well, demonstrated by successful products like <code>Node.js</code>. Every incarnation of oma ships with a reference implementation in JavaScript. The sole purpose of this reference implementation is to provide an executable prototype of the architecture. JavaScript is the obvious choice for a reference implementation, because terminals are web browsers that must be programmed in JavaScript. There is no compelling reason to complicate the reference implementation with another programming language. However, the success of oma depends on the availability of alternative component implementations, in as many programming language as possible. The architecture merely aims to define how components communicate over HTTP. The choice of the most suitable implementation language for an application, a process or an open mainframe is outside the scope of oma.
    </p>
    <p>
The remainder of this chapter explains the philosophy behind oma in more detail. The next five chapters describe the web services of oma. The remaining chapters discuss architectural features that cross service boundaries.
    </p>
    <h2>Rich user experience vs easy application management</h2>
    <p>
In the beginning, a mainframe was a mysterious machine in large banks and insurance companies. Terminals were primitive input devices, e.g. teletypewriters, which offered a poor user experience. Monochrome monitors with keyboards improved the experience, although a happy user was never an important design goal. Most users were employees that accepted how an application worked, no matter how stupid it may have been. Unhappy users are unlikely to complain when their jobs are at stake.
    </p>
    <p>
Personal computing fundamentally changed the IT industry. The PC offered a rich user experience at an affordable price. New technologies, e.g. the mouse, paved the way for advanced graphical user interfaces. The competitive PC market forced companies to innovate. Unhappy customers are likely to switch to a competitor when they feel they wasted money on an inferior product.
    </p>
    <p>
Application management is a nightmare on networks with PCs, because every PC is equipped with its own operating system and application versions. The desire to centralize application management collides with the personal freedom to install applications. It's impossible to have both. An organization is likely to run into situations where the complexity of application management has a negative impact on the user experience, e.g. incompatibilities between versions.
    </p>
    <p>
Web applications are a compromise. A web browser, installed on every personal device, displays HTML pages of a web application. The organization maintains the current version of the application on a web server. The user remains in control of applications that are installed on the device. Web applications were initially restricted to very simple, form-based tasks, because the user experience was awful. New web standards, and better support for existing standards across browsers, enabled web applications to offer a decent user experience in mainstream browsers, for a broad range of tasks.
    </p>
    <p>
Web standards slowly evolve to encorporate the latest technologies. It's an unfortunate consequence of the standardization process. Web standards were unable to keep up with the speed of the mobile revolution. Many web applications were hardly usable on mobile devices. The bad experience explains why users prefer native apps. Although the management of native apps on mobile devices is delegated to app stores of vendors, the distribution of a new app version is more complex than upgrading a web application. Many organizations take this complexity for granted, because they fear unhappy users. 
    </p>
    <p>
A hybrid solution that fetches and presents snippets from the web inside native apps, combines the best of both worlds. The native app is responsible for an intuitive integration with the mobile device OS, while the snippets are easy to manage and to upgrade on web servers. It is a new equilibrium that keeps users and organizations happy.
    </p>
    <p>
The short history of past application architectures is an important lesson for oma. A universal application that offers a good user experience across terminal devices, now and in the future, is unrealistic. Many devices have capabilities that cannot be emulated on other types of devices. The open mainframe architecture encourages experimentation with device-specific features that are captured in emerging web standards/proposals. Frontend developers design suitable data abstractions, which convey the effects of a new web technology as delta actions in a virtual user interface. Backend developers employ these abstractions in the virtual user interface to optimize the real user experience on popular devices.
    </p>
    <h2>Typed JSON</h2>
    <p>
The open mainframe architecture augments JSON with a type system to enforce more rigorous rules about structure. The type system introduces a simple definition language to create data types, which specify how to marshal and unmarshal data values in JSON. A data value is either a basic, list, dictionary or record value. Typed JSON is an essential ingredient of oma, because data types form the glue between architectural components. The dynamic type of a value must be preserved when values are communicated over the wire. Delta sessions solve contravariance problems with the dynamic types of values.
    </p>
    <p>
The JSON representation of a data value is either compact or full. A <dfn>full representation</dfn> includes the dynamic type of the represented value. A <dfn>compact representation</dfn> is on the other hand untyped. Consider the list type <code>[string]</code>. The compact representation of an empty string list is an empty array <code class="literal">[]</code>. The full representation is a JSON object <code class="literal">{$:'[string]',_:[]}</code>. The dollar entry defines the dynamic type of the value and the underscore represents the untyped value. Although a compact JSON representation is preferable, a full representation is unavoidable when the dynamic type of a value cannot be inferred.
    </p>
    <p>
Data types are defined in modules. Type definitions specify a data interface to some aspect of a software system. For example, a terminal loads modules that define data types for virtual user-interface elements like buttons and sliders. The terminal loads other modules that implement concrete user-interface elements in JavaScript. In oma terminology, these implementations are known as manifestations. A <dfn>manifestation</dfn> determines how a data value in a session model behaves in a runtime environment. Manifestations separate structural from behavioral concerns. A virtual slider element in a session model is unaware of its manifestation in the browser DOM, which presents a real slider the user can interact with.
    </p>
    <h2>Multidisciplinary teams</h2>
    <p>
Applications are the responsibility of teams. An application architecture should carefully balance the needs of all team disciplines that are involved in an application's lifecycle.
    </p>
    <p>
Frontend developers are responsible for the manifestations of virtual user-interface elements in a browser environment. Backend developers write application logic to control virtual user interfaces. The modular organization of assets streamlines cooperation between these disciplines in a team. They have to agree which module versions are bundled in an application deployment. The <dfn>application image</dfn> of a deployment lists all modules that a terminal may need to load when it starts the application.
    </p>
    <p>
A backend developer probably does not change the application image while testing new application logic. It might even be possible to test a new version of the application without redeploying it, depending on the implementation language and development environment. A frontend developer on the other hand, redeploys the same application logic over and over again, but with different images, to test new manifestations in a browser environment. The source assets of these manifestations are conveniently uploaded in heavy deployments. Frontend and backend developers can deploy their test applications on a remote mainframe. The impact of oma on development environments should almost be negligible. Developers are not forced to install a variety of tools on their local machines to test their creations. They post the HTTP request for a heavy or light deployment to a mainframe, an easy feat in many development environments. After successful deployment, developers start the test application by navigating a web browser to a welcome URL.
    </p>
    <p>
The early stages of an application's lifecycle focus on frantic development, but at some point, an application deployment should be production-ready. Other disciplines in the team are responsible for maintenance of the production site. Although developers still continue to work on the product, new developments only reach the production site after passing a slew of quality assurance tests. To satisfy the needs of QA team members, an architecture must support concurrent deployments of different application versions. URL-based navigation of terminals tackles this issue in oma. As long as an application deployment is reachable at some welcome URL, users can start the appropriate application version in a terminal and test it.
    </p>
    <p>
The open mainframe architecture stresses the importance of a scalable network infrastructure. Team members that manage the network infrastructure are not confronted with a myriad of protocols and technologies, because all communication between tiers is based on HTTP. Large Internet companies demonstrate every day that HTTP, and HTTPS, scales to millions of connections. The following figure shows the network topology of a typical production site in oma. An arrow is the initiation of a TCP connection between networks. The mainframe network is a demilitarized zone (DMZ), separated from frontend and backend networks. The frontend firewall filters connections from the Internet, it handles encryption of HTTPS connections and it serves static assets. Other HTTP requests from the Internet are forwarded to an address, or multiple addresses, in the mainframe network. Backend firewalls similarly filter, forward and balance HTTP requests from networks where deployed applications are running.
    </p>
    <table class="network-stack">
      <tbody>
        <tr class="network layer">
          <td colspan="7">
Internet
          </td>
        </tr>
        <tr class="network-flow">
          <td colspan="7">
&darr;
          </td>
        </tr>
        <tr class="firewall layer">
          <td colspan="7">
Frontend firewall
          </td>
        </tr>
        <tr class="network-flow">
          <td colspan="2">
&darr;
          </td>
          <td colspan="3">
&darr;
          </td>
          <td colspan="2">
&darr;
          </td>
        </tr>
        <tr class="network layer">
          <td colspan="7">
Mainframe network
          </td>
        </tr>
        <tr class="network-flow">
          <td>
&uarr;
          </td>
          <td>
&uarr;
          </td>
          <td>
&uarr;
          </td>
          <td class="network-separator" />
          <td>
&uarr;
          </td>
          <td>
&uarr;
          </td>
          <td>
&uarr;
          </td>
        </tr>
        <tr class="firewall layer">
          <td colspan="3">
Backend firewall<sub>1</sub>
          </td>
          <td class="network-separator" />
          <td colspan="3">
Backend firewall<sub>2</sub>
          </td>
        </tr>
        <tr class="network-flow">
          <td colspan="3">
&uarr;
          </td>
          <td class="network-separator" />
          <td colspan="3">
&uarr;
          </td>
        </tr>
        <tr class="network layer">
          <td colspan="3">
Local network<sub>1</sub>
          </td>
          <td class="network-separator" />
          <td colspan="3">
Local network<sub>2</sub>
          </td>
        </tr>
      </tbody>
    </table>
    <h2>Application domains</h2>
    <p>
Mainframes are traditionally used in administrative domains. Although oma is more domain agnostic, there are inherent limitations.
    </p>
    <p>
Developers should be careful not to neglect the Law of Leaky Abstractions. It is tempting to treat a virtual user interface as an event-driven user interface, commonly found in native window systems, but the separation of presentation and application concerns on distinct networks is not an implementation detail. Response times in window systems are measured in microseconds. Network delays are on the other hand measured in milliseconds. When a user interaction takes place in a terminal, there is a network delay before a backend process is informed about a delta action in a virtual user interface. There is yet another network delay before the effects in the user interface are reported back to the terminal. A thousandfold difference cannot be ignored. A delay of ten milliseconds is perceived as instantaneous. Having to wait for ten seconds absolutely kills the user experience. A virtual user interface is bound to leak if network delay is not a fundamental part of its design.
    </p>
    <p>
When designing virtual user interfaces, team members divide responsibilities between presentation logic in frontend terminals and application logic in backend processes. They negotiate a balance that supports an intuitive user experience on terminal devices with average network connectivity. User perception must be the decisive factor to resolve design issues. This may involve optimistic trickery like starting an animation in a terminal to show results, before the backend process has produced the results. Leave it to the imagination of creative teams to design virtual user interfaces for a broad range of application domains.
    </p>
    <h2>Share and enjoy</h2>
    <p>
The open mainframe architecture is released under the liberal MIT license. Developers are encouraged to examine the sources of the reference implementation. The reference implementation of oma complements the service descriptions in this document with an executable prototype. This is a vital instrument for developers that wish to implement oma components in their favorite programming languages. Developers are of course also able to contribute to the quality of the reference implementation itself. The JavaScript sources should communicate the philosophy of oma as clearly as possible.
    </p>
    <p>
In memory of Douglas Adams, oma adopts the slogan of the Sirius Cybernetics Corporation. Share and enjoy!
    </p>
    <h1>Delta service</h1>
    <p>
The delta service is the beating heart of oma. A client and server side, sharing and synchronizing a model, is a recurring theme in the architecture. Terminal, application and process sessions are delta sessions, albeit with different models and/or directions. This chapter explains how data types describe the structure of session models, how delta sessions map to HTTP resources on a web server, and how the delta protocol expects the client and server side to behave.
    </p>
    <h2>Data types</h2>
    <p>
The model of a delta session is the placeholder for a typed data value. Data types restrict what kind of actions clients and servers can perform on models, e.g. a number cannot be stored at a location that expects a string. Record types specify additional delta annotations for record fields. These annotations define whether the client, the server, or both sides of the session can modify a record field. By default, the server side can change a field, but the client cannot. The annotations also distinguish between data and event fields in a model. A <dfn>data field</dfn> is the placeholder for a data value. An <dfn>event field</dfn> is the origin of a transient event. Events are reported in delta messages, but they are not persisted in the session model.
    </p>
    <p>
The following data types define the structure of values.
    </p>
    <ul>
      <li>
        <p>
The basic types are <code>none</code>, <code>boolean</code>, <code>number</code> and <code>string</code>. The only member of <code>none</code> is <span class="literal"><code>null</code></span>.
        </p>
      </li>
      <li>
        <p>
An optional type, denoted with a closing question mark, adds <span class="literal"><code>null</code></span> as a type member. Members of optional type <code>boolean?</code> are either <span class="literal"><code>true</code></span>, <span class="literal"><code>false</code></span> or <span class="literal"><code>null</code></span>.
        </p>
      </li>
      <li>
        <p>
A wildcard type, denoted with an asterisk, matches all types without a <span class="literal"><code>null</code></span> member. An optional wildcard type <code>*?</code> matches any type.
        </p>
      </li>
      <li>
        <p>
An enumeration type enumerates one or more distinct string choices. Enumerated choices are surrounded by double quotes and separated by underscores, e.g. <code>"a"_"b"_"c"</code>.
        </p>
      </li>
      <li>
        <p>
A list type surrounds an element type with square brackets. A member of list type <code>[string?]</code> is a sequence of optional strings.
        </p>
      </li>
      <li>
        <p>
A dictionary type surrounds an element type with angle brackets. A member of dictionary type <code>&lt;number&gt;</code> maps string keys to basic numbers.
        </p>
      </li>
      <li>
        <p>
A record type surrounds comma-separated field definitions with curly brackets. A colon associates a name with a type in a field definition. Record type <code>{bar:[number]}</code> defines field <code>bar</code> whose value is a list with numbers.
        </p>
      </li>
      <li>
        <p>
A union type contains type alternatives, separated by vertical bars. A member of union type <code>number|string</code> is either a basic number or string.
        </p>
      </li>
    </ul>
    <h3>Data definition language</h3>
    <p>
A delta session exports a <dfn>typespace</dfn> that binds names to type expressions and macros. A <dfn>type expression</dfn> is evaluated in a typespace. A <dfn>type macro</dfn> is a template that needs one or more type parameters to evaluate the resulting data type. Both sides of a session parse and evaluate the expressions and macros of the typespace to establish a common vocabulary for model synchronization. Typespaces add a convenient level of indirection to organize and to reuse type definitions, for example type additions to merge the fields of record types.
    </p>
    <p>
The definitions in a typespace must be closed under evaluation. Every type variable in an expression must be bound to a macro argument. Every type name must be bound to a macro or expression in the typespace. The complete grammar of type definitions is given below in EBNF notation.
    </p>
<pre>TypeDef     =  TypeMacro | TypeExpr
TypeMacro   =  <span class="literal">"("</span> TypeArg {<span class="literal">","</span> TypeArg} <span class="literal">")"</span> TypeExpr
TypeArg     =  <span class="pattern">VARIABLE</span> <span class="literal">"="</span> TypeExpr
TypeExpr    =  TypeExpr<sub>1</sub> [<span class="literal">"?"</span>]
TypeExpr<sub>1</sub>   =  TypeExpr<sub>2</sub> {<span class="literal">"|"</span> TypeExpr<sub>2</sub>}
TypeExpr<sub>2</sub>   =  TypeExpr<sub>3</sub> {<span class="literal">"+"</span> TypeExpr<sub>3</sub>}
TypeExpr<sub>3</sub>   =  TypeExpr<sub>4</sub> | <span class="pattern">VARIABLE</span> | <span class="pattern">NAME</span> [<span class="literal">"("</span> TypeExpr {<span class="literal">","</span> TypeExpr} <span class="literal">")"</span>]
TypeExpr<sub>4</sub>   =  <span class="literal">"*"</span> | BasicType | EnumType | ListType | DictType | RecordType
BasicType   =  <span class="literal">"none"</span> | <span class="literal">"boolean"</span> | <span class="literal">"number"</span> | <span class="literal">"string"</span>
EnumType    =  <span class="pattern">CHOICE</span> {<span class="literal">"_"</span> <span class="pattern">CHOICE</span>}
ListType    =  <span class="literal">"["</span> TypeExpr <span class="literal">"]"</span>
DictType    =  <span class="literal">"&lt;"</span> TypeExpr <span class="literal">"&gt;"</span>
RecordType  =  <span class="literal">"{"</span> [Fields] <span class="literal">"}"</span>
Fields      =  Field {<span class="literal">","</span> Field}
Field       =  <span class="pattern">FIELD</span> <span class="literal">":"</span> TypeExpr {Annotation}
Annotation  =  <span class="literal">"@"</span> <span class="pattern">FIELD</span> <span class="literal">"="</span> <span class="pattern">FIELD</span></pre>
    <p>
The token patterns are defined by the following regular expressions.
    </p>
<pre><span class="pattern">NAME</span>      [<span class="literal">A</span>-<span class="literal">Z</span>][<span class="literal">0</span>-<span class="literal">9</span><span class="literal">A</span>-<span class="literal">Z</span><span class="literal">a</span>-<span class="literal">z</span>]+(<span class="literal">.</span>[<span class="literal">A</span>-<span class="literal">Z</span>][<span class="literal">0</span>-<span class="literal">9</span><span class="literal">A</span>-<span class="literal">Z</span><span class="literal">a</span>-<span class="literal">z</span>]+)*
<span class="pattern">FIELD</span>     [<span class="literal">a</span>-<span class="literal">z</span>][<span class="literal">0</span>-<span class="literal">9</span><span class="literal">A</span>-<span class="literal">Z</span><span class="literal">a</span>-<span class="literal">z</span>]*
<span class="pattern">VARIABLE</span>  [<span class="literal">A</span>-<span class="literal">Z</span>]
<span class="pattern">CHOICE</span>    <span class="literal">"</span>[<span class="literal">0</span>-<span class="literal">9</span><span class="literal">A</span>-<span class="literal">Z</span><span class="literal">a</span>-<span class="literal">z</span>]+<span class="literal">"</span></pre>
    <h3>Type definition</h3>
    <p>
Data types are defined in module configurations. The following JavaScript extract shows the definitions of standard type names in oma.
    </p>
<pre><span class="keyword">function</span> configure(module) {
  &hellip;
  module.datatype = {
    Any: <span class="literal">'*?'</span>, <span class="comment">// any value, including null</span>
    Flag: <span class="literal">'"y"?'</span>, <span class="comment">// truthy flags</span>
    Text: <span class="literal">'string|[string]'</span>, <span class="comment">// line(s) of text</span>
    List: <span class="literal">'(T=Any)[T]'</span>, <span class="comment">// sequenced list</span>
    Dict: <span class="literal">'(T=Any)&lt;T&gt;'</span>, <span class="comment">// dictionary mapping</span>
    Maybe: <span class="literal">'(T=*)T?'</span> <span class="comment">// perhaps null</span>
  }
  &hellip;
}</pre>
    <p>
Data type <code>Any</code> matches any type, including optional ones. Data type <code>Flag</code> is a boolean-like type, where <span class="literal">null</span> stands for false and <span class="literal">"y"</span> for true. Data type <code>Text</code> avoids end-of-line problems in textual data. Newline characters <span class="literal">"\n"</span>, <span class="literal">"\r"</span> or combinations of these characters are treated as whitespace characters, not as line separators. A new line of textual data is represented as an additional string in the list. The standard macros <code>List</code>, <code>Dict</code> and <code>Maybe</code> construct list, dictionary and optional types. For example, <code>Maybe(number)</code> is a more verbose way to express <code>number?</code>. When a macro is evaluated without actual arguments, the formal arguments are bound to their default types. The expression <code>List</code> is thus a shorthand for <code>List(Any)</code>. The remainder of this document employs a terse notation to bind names to type definitions. The next example shows the previous definitions in this notation. The translation to the corresponding JavaScript in a module configuration is straightforward.
    </p>
<pre>Any: *?
Flag: "y"?
Text: string | [string]
List(T=Any): [T]
Dict(T=Any): &lt;T&gt;
Maybe(T=*): T?</pre>
    <h3>Type evaluation</h3>
    <p>
It's not possible to make an optional type more optional. It is syntactically already impossible, i.e. <code>U??</code> is not a valid type expression, but the evaluation of a type expression can still run into this problem. Optionality must be an idempotent operation in a typespace.
    </p>
<pre><span class="rule-condition">S = T?<br/>T = U?</span><span class="rule-conclusion">S = U?</span></pre>
    <p>
An optional <code>none</code> type is nonsensical. An optional value is either <code class="literal">null</code> or a value of the <dfn>mandatory type</dfn>. This assumes the mandatory type describes other values than <code class="literal">null</code>, which excludes <code>none</code>.
    </p>
<pre><span class="rule-condition">S = none?</span><span class="rule-conclusion">S = none</span></pre>
    <p>
Type addition <code>S</code> combines the fields of record types <code>T</code> and <code>U</code>. If a field is defined in both <code>T</code> and <code>U</code>, the field definition from <code>U</code> ends up in addition <code>S</code>. The field of <code>U</code> is said to refine the inherited field of <code>T</code>. The refined field type is not restricted by the inherited field type.
    </p>
<pre><span class="rule-condition">S = T + U</span><span class="rule-conclusion">S = { fields from T and not in U, &hellip;, fields from U, &hellip; }</span></pre>
    <p>
A <code>none</code> alternative lifts a union type to an optional type. The optional type is a more concise shorthand for the union type. Union types should not have a <code>none</code> alternative. The optional type is always preferred over the union type.
    </p>
<pre><span class="rule-condition">S = T | none</span><span class="rule-conclusion">S = T?</span></pre>
    <p>
An optional alternative lifts a union type to an optional type. Union types should not have optional alternatives. Optional alternatives must be replaced by mandatory types in the lifted union type <code>S<sub>1</sub></code>.
    </p>
<pre><span class="rule-condition">S = T | U<br/>T = V?</span><span class="rule-conclusion">S<sub>1</sub> = V | U<br/>S = S<sub>1</sub>?</span></pre>
    <p>
A wildcard alternative lifts a union type to a wildcard type. Union types cannot have a wildcard alternative.
    </p>
<pre><span class="rule-condition">S = T | *</span><span class="rule-conclusion">S = *</span></pre>
    <p>
A union type flattens alternatives. Union types should not have nested union alternatives.
    </p>
<pre><span class="rule-condition">S = T | U<br/>T = V | W</span><span class="rule-conclusion">S = V | W | U</span></pre>
    <p>
A union type merges enumeration alternatives. The distinct choices of enumeration alternatives are merged in one enumeration type. At most one enumeration alternative is allowed in a union type.
    </p>
<pre><span class="rule-condition">S = T | "u<sub>1</sub>"_"u<sub>2</sub>" &hellip; _"u<sub>n</sub>"<br/>T = "t<sub>1</sub>"_"t<sub>2</sub>" &hellip; _"t<sub>m</sub>"</span><span class="rule-conclusion">S = "t<sub>1</sub>"_"t<sub>2</sub>" &hellip; _"t<sub>m</sub>"_"u<sub>1</sub>"_"u<sub>2</sub>" &hellip; _"u<sub>n</sub>"</span></pre>
    <p>
An enumeration alternative is pointless, if basic type <code>string</code> is another alternative, because an enumeration is a subtype of <code>string</code>.
    </p>
<pre><span class="rule-condition">S = T | string<br/>T = "t<sub>1</sub>"_"t<sub>2</sub>" &hellip; _"t<sub>m</sub>"</span><span class="rule-conclusion">S = string</span></pre>
    <p>
Duplicate alternatives are superfluous. This rule does not test for type equivalence, because alternatives are considered duplicates if they have identical definitions. Union types should not specify identical alternatives.
    </p>
<pre><span class="rule-condition">S = T | T</span><span class="rule-conclusion">S = T</span></pre>
    <h3>Marshal and unmarshal</h3>
    <p>
The marshal function of a type computes the JSON representation of a data value. The unmarshal function is the inverse function from JSON representation back to data value. Marshalling a data value and unmarshalling its JSON representation should produce an equal value. Data values are equal, if they convey the same structure, and if they are members of the same dynamic type.
    </p>
    <p>
The marshal and unmarshal function of a basic type is the identity function. The JSON representation of a basic value cannot be distinguished from the value itself. Consequently, basic values cannot carry additional type information. A typespace can define an alias for a basic type, but a basic value cannot be a member of the type alias. The dynamic type of a basic value is implicitly encoded in the value.
    </p>
    <p>
Members of enumeration types are represented as JSON strings, and thus by default, reconstructed as basic string values. This loss of type information is not a problem, if the reconstruction site expects an enumerated choice. Record type <code>Foo</code> in the next example expects basic string <code class="literal">"a"</code> or <code class="literal">"b"</code> when a value for field <code>bar</code> is constructed. The type information, required to validate a basic string as an enumerated choice, is available at the construction site. 
    </p>
<pre>Foo: {
  bar: "a"_"b"
}</pre>
    <p>
Marshal functions of list, dictionary and record types compute a compact or full JSON representation. If the inferred type at the construction site is identical to the dynamic type of a data value, a compact representation suffices. Otherwise the full representation is required to preserve the dynamic type of the value. Type preservation solves contravariance problems when data values in session models are subjected to mutations. The dynamic type of a model value furthermore determines the manifestation in a runtime environment. If dynamic types are not properly preserved, a session model will not exhibit the intended behavior.
    </p>
    <p>
The compact representation of a list value is a JSON array. The full representation stores this array in the underscore entry of a JSON object. The list type is stored in the dollar entry. List values benefit the most from a compact representation, because it avoids the creation of a wrapper object. For example, the array <code class="literal">[4,2]</code> is a compact representation for a value of list type <code>[number]</code>. The full representation <code class="literal">{$:'[number]',_:[4,2]}</code> wraps the array in an extra object to preserve the dynamic type of the list value.
    </p>
    <p>
The only difference between the compact and full representation of a record value is the missing dollar entry in the compact representation. Both representations are JSON objects. The full representation <code class="literal">{$:'Foo',bar:'b'}</code> includes information about the dynamic type of a record value, which is dropped from the compact representation <code class="literal">{bar:'b'}</code>. The benefits of a compact representation are noticeable when record values have few fields. If records have many fields, the penalty for extra dollar entries in full representations is negligible.
    </p>
    <p>
The JSON representation of optional record fields is optimized. The marshal function of a record type does not include a data field in the JSON representation, if the field value is <code class="literal">null</code>. The unmarshal function of a record type initializes a data field to <code class="literal">null</code>, if the field is not present in the JSON representation. This optimization turns standard type <code>Flag</code> into an efficient type for boolean-like fields with a bias towards false. A cleared flag, i.e. the common case, is missing, but a set flag must be explicitly initialized to <code class="literal">"y"</code> in the JSON representation.
    </p>
    <p>
The compact representation of a dictionary value is a JSON object with an underscore entry that contains another JSON object. The nested JSON object maps dictionary keys to values. Dictionary entries cannot be represented in the root JSON object, because this results in an ambiguous representation when a dollar and/or an underscore is a dictionary key. Full representations of dictionaries employ the same scheme as list values, i.e. a dollar for the type information and an underscore for the untyped container with elements. The full representation of an empty dictionary with numbers is <code class="literal">{$:'&lt;number&gt;',_:{}}</code>. The omission of the dollar entry in the compact representation <code class="literal">{_:{}}</code> is similar to record values.
    </p>
    <p>
The marshal function of a wildcard type produces full representations of list, dictionary and record values, because an inferred wildcard type at a construction site cannot match with the dynamic type of a data value.
    </p>
    <p>
Although an inferred optional type also does not match the dynamic type of a data value, the marshal function of an optional type produces a compact representation, if the dynamic type matches the mandatory type. For example, when the inferred type is <code>Foo?</code>, the compact representation <code class="literal">{bar:'a'}</code> suffices to preserve record type <code>Foo</code>. An optional value, that is not <code class="literal">null</code>, must be a member of the mandatory type.
    </p>
    <p>
The marshal function of an inferred union type produces the compact representation of a list, dictionary or record value, if there is only one list, dictionary or record alternative to choose from. Standard type <code>Text</code> is the union type <code>string|[string]</code>. The compact representation of a <code>Text</code> value with two lines, e.g. <code class="literal">['One.','Two.']</code>, cannot be confused with a string alternative for one-liners. However, the marshal function of a union type with two list alternatives like <code>[number]|[string]</code> produces a full representation, because it is not always possible to reconstruct the dynamic type of a value from a compact representation. It's unclear whether an empty array represents an empty list with numbers or strings.
    </p>
    <h3>Delta annotations</h3>
    <p>
A record field is annotated to specify field characteristics in a delta session. A field without delta annotations is a data field that the server side can update. When a session model is a record value of type <code>Foo</code>, the server side can send an action in a delta response that assigns a new number to field <code>bar</code>. The client side can only read the number in the model.
    </p>
<pre>Foo: {
  bar: number
}</pre>
    <p>
An <code>@event</code> annotation specifies an event field. The annotation value is <code>client</code> or <code>server</code>. A record value does not marshal event fields in a JSON representation. In the next example, field <code>bar</code> is a server event field. The server reports an occurence of this event in a delta response. Field type <code>none</code> implies an occurence is unstructured. The client is informed about an occurence, but the reported event does not provide any additional information.
    </p>
<pre>Foo: {
  bar: none @event=server 
}</pre>
    <p>
A client event field is the origin of an event in a delta request. In the next example, the client informs the server about an occurence of event field <code>bar</code> as soon as possible, which is the default client reaction to an event occurence. The field type indicates an occurence conveys a boolean value.
    </p>
<pre>Foo: {
  bar: boolean @event=client 
}</pre>
    <p>
A <code>@delay</code> annotation alters the client reaction to an event occurence. The annotation value is <code>block</code>, <code>flush</code> or <code>forever</code>. The client sends a delta request with an occurence of event field <code>bar</code> in the next example as soon as possible. While waiting for the delta response, the blocked client is not allowed to modify the session model. The model is locked and the client has to wait for the server to produce the side effects of processing the event.
    </p>
<pre>Foo: {
  bar: boolean @event=client @delay=block
}</pre>
    <p>
The client buffers an occurence of event field <code>bar</code> in the next example. The actions in this buffer are flushed and added to the next request, when the client decides it's time to send the delta request. The server is not informed about buffered actions until the client flushes.
    </p>
<pre>Foo: {
  bar: boolean @event=client @delay=flush
}</pre>
    <p>
The server is not interested in the occurence of event field <code>bar</code> in the next example. It expects the client to delay occurences indefinitely. The server has to delete or update the <code>@delay</code> annotation if it wants to be informed about occurences.
    </p>
<pre>Foo: {
  bar: boolean @event=client @delay=forever
}</pre>
    <p>
The initial value of a <dfn>meta field</dfn> is a dictionary that holds the specified annotations of a field definition. A member of record type <code>Foo</code> with field <code>bar</code> also contains meta field <code>@bar</code>, which maps annotation names to values. The type of a meta field is predefined as <code>&lt;string&gt;</code>, but in all other regards, a meta field is a regular data field that the server side can target with delta actions.
    </p>
    <p>
A <code>@data</code> annotation specifies a data field that is modifiable on the client side. The annotation value is <code>client</code> or <code>both</code>. In the next example, both client and server can update data field <code>bar</code> in a session model with a new string value. When the client changes the field, the default reaction is to report the modification in a delta request as soon as possible.
    </p>
<pre>Foo: {
  bar: string @data=both
}</pre>
    <p>
A <code>@delay</code> annotation specifies an alternative client reaction to a data modification. The annotation value is <code>block</code>, <code>flush</code>, <code>pause</code> or <code>ponder</code>. The values <code>block</code> and <code>flush</code> have the same meaning for data and event fields. A blocking client waits for a response after a modification. A flushing client buffers a modification and flushes it later. In the next example, the client buffers a modification of field <code>bar</code> as well. However, when this modification is still the most recent field modification after a small pause, the client sends a delta request as soon as possible. The value <code>ponder</code> increases the delay of the last modification to a few seconds, giving the client more time to think about what the field value should be, before the server is informed about it.
    </p>
<pre>Foo: {
  bar: string @data=both @delay=pause
}</pre>
    <p>
When the client owns a data field, the server cannot modify the field value in a session model. Although the server conceptually owns the whole model, the server only computes the initial value of field <code>bar</code> in the next example. Once the field value is part of the model, the client becomes the sole owner. The field annotations, contained in meta field <code>@bar</code>, remain under server control.
    </p>
<pre>Foo: {
  bar: string @data=client
}</pre>
    <h2>Delta session</h2>
    <p>
Delta sessions are directories on web servers of open mainframes. A mainframe hosts a number of HTTP resources for a delta session. An HTTP client accesses a session resource to initiate a session operation. Many session operations use data types to describe parameters and results.
    </p>
    <h3>Update model</h3>
    <h4><code>POST &hellip;/do</code></h4>
    <p>
The most prominent session resource is <code>do</code> that performs delta actions on the model. The posted body of an HTTP request encodes the compact JSON representation of a delta message. The HTTP response contains the compact representation of the next delta message. The direction of the session determines whether the HTTP request contains a delta request or a delta response.
    </p>
    <p>
The sequence number of a <code>Delta.Message</code> is an integer that distinguishes between a delta request and response. Requests have positive, odd sequence numbers. Responses have nonnegative, even sequence numbers. A delta message is denoted as &#x03b4;(n) in this document, where n is a sequence number, e.g. &#x03b4;(1) is the first delta request, sent by the client. The actions of response &#x03b4;(2m) reflect side effects that resulted from processing actions of request &#x03b4;(2m-1). Field <code>lease</code> counts the number of seconds the receiver of a message has left before it should produce the next delta message. Field <code>retry</code> is truthy if the message was retried after a communication failure.
    </p>
<pre>Delta.Message: {
  sequence: number,
  actions: [Delta.Action],
  lease: number,
  retry: Flag
}</pre>
    <p>
A <code>Delta.Action</code> occurs in some part of the model. Field <code>path</code> locates this part in the model. An array of path elements describes the route from the starting point of the model, i.e. the root value, to the value where the action takes place. When a path element is a string, it selects a record field or dictionary entry for the resolution of the remaining path elements. A numeric path element selects an element from a list value for the remainder of the path. List values have one-based indices.
    </p>
<pre>Delta.Action: {
  path: [string | number]
}</pre>
    <p>
A <code>Delta.Assign</code> action mutates a value in the model. A <code>Delta.Signal</code> action reports a client or server event in the model. Both assignments and signals must be properly typed. The path of an action infers what type of value can be assigned or what type of event can be signalled. For example, if the path leads to an element of a list in the model, the value to assign must be a member of the element type.
    </p>
<pre>Delta.Assign: Delta.Action + {
  value: Any
}
Delta.Signal: Delta.Action + {
  event: Any
}</pre>
    <p>
A <code>Delta.Replace</code> action works on a list value in a session model. The path of a replacement action locates the position in the list where action values replace existing elements in the model. A <code>Delta.Delete</code> action specifies keys to remove from a dictionary value in the model.
    </p>
<pre>Delta.Replace: Delta.Action + {
  values: [Any]
}
Delta.Delete: Delta.Action + {
  keys: [string]
}</pre>
    <p>
A <code>Delta.Goto</code> action jumps to a location in the model from which the other relative actions are performed. A <code>Delta.Update</code> action fuses several assignments into a single action. Field <code>assigns</code> is a dictionary whose entry keys specify the assignment locations for entry values. If the path of an update action locates a record or dictionary in the session model, the assignment keys identify record fields or dictionary entries. If a list is located at the update path, the assignment keys are string representations of integer indices. Goto and update actions are optional optimizations that avoid path duplications to minimize the payload of delta messages.
    </p>
<pre>Delta.Goto: Delta.Action + {
  actions: [Delta.Action]
}
Delta.Update: Delta.Action + {
  assigns: &lt;Any&gt;
}</pre>
    <h3>Query session</h3>
    <p>
Query operations are nonintrusive. They cannot affect the session state in any way.
    </p>
    <h4><code>GET &hellip;/poll</code></h4>
    <p>
An HTTP client polls a delta session to inspect the current session status. The client cannot cache the HTTP response that contains the compact JSON representation of a <code>Delta.Status</code> record. Field <code>expect</code> is the sequence number of a delta message. When even, the server side is supposed to produce the next delta response. Otherwise the client side should come up with the next delta request.  Field <code>after</code> counts how many lease seconds are remaining for the producing side. A negative <code>after</code> value means the next message is overdue. The absolute value counts how many seconds the producing side is late.
    </p>
<pre>Delta.Status: {
  expect: number,
  after: number
}</pre>
    <h4><code>GET &hellip;/model</code></h4>
    <p>
An HTTP client sends a request to this resource to obtain the definition of data type <code>Delta.Model</code>, which describes the root value of a delta session. This type name is used in standard types, but it lacks a standard definition. The client should cache the HTTP response with the textual source of a type definition. The model of a session holds a list, dictionary or record value. This composed value is the starting point to manipulate the session model.
    </p>
    <h4><code>GET &hellip;/dump</code></h4>
    <p>
A dump operation returns the complete state of a session. An HTTP client should not cache the response with the compact representation of a <code>Delta.Dump</code> record. The record combines the status of a session with the root value. A dump enables restoration of a session model. A browser must restore the model of a terminal session after a page refresh has destroyed the old model.
    </p>
<pre>Delta.Dump: Delta.Status + Delta.Root
Delta.Root: {
  root: Delta.Model
}</pre>
    <h4><code>GET &hellip;/types</code></h4>
    <p>
Both sides of a delta session parse and evaluate type definitions. This resource exports the typespace of a session, minus the definition of <code>Delta.Model</code>. The HTTP response contains a JSON object that maps names to type expressions and macros. An HTTP client should cache the response.
    </p>
    <p>
With the removal of <code>Delta.Model</code>, the other type definitions of a typespace are reusable in different kinds of delta sessions. For example, this resource exports exactly the same JSON object in an application session as it exports in a process session of the application.
    </p>
    <h3>Manipulate lease</h3>
    <p>
The easiest way to simulate bidirectional synchronization is to specify tiny lease periods in delta messages. This gives the illusion that any side can change the model at any time. Unfortunately, it also causes a lot of superfluous delta messages, if the average client and server perform actions on the session model at a much lower frequency than they exchange delta messages. The ready and greedy resource of a delta session provide a more efficient solution.
    </p>
    <h4><code>GET &hellip;/ready</code></h4>
    <p>
If an HTTP client has the initiative to send the next delta message, and it also has a reasonable amount of lease time left, it can send a request to this session resource. The HTTP response, which cannot be cached, may take a while to arrive, but when it arrives before the lease period expires, it contains the new lease time. A zero lease time enables the other side to instruct the HTTP client to send the next delta message right away. The other side can influence the lease period without altering the sequential flow of delta messages. It is still up to the HTTP client to produce the next delta message before the lease period expires. 
    </p>
    <h4><code>GET &hellip;/greedy</code></h4>
    <p>
If the other side still has a reasonable amount of lease time left to produce the next delta message, an HTTP client can send a request to this session resource. The HTTP response contains the remaining lease time for the other side. It cannot be cached. If the response contains a zero, the lease time was reset, and the HTTP client should receive the next delta message shortly. If the response contains a positive number, the lease time could not be reset. The HTTP client may have to wait for the lease period to expire before it receives the next delta message. A negative number indicates the next delta message from the other side is already overdue.
    </p>
    <h3>Upload file</h3>
    <p>
The client side of a paired session uploads files that the server side downloads. When a frontend terminal uploads files, the backend process downloads them. The delta service maintains a <dfn>binary pipe</dfn> to transfer the files from the client to the server side. The transfer is coordinated with delta events in the model, but the binary file content is not stored in the model.
    </p>
    <p>
A <code>Delta.Blob</code> record describes binary content. The description provides the byte size and the MIME type. An empty string indicates an unknown MIME type.
    </p>
<pre>Delta.Blob: {
  size: number,
  type: string
}</pre>
    <h4><code>POST &hellip;/plumb</code></h4>
    <p>
The server side of a paired session posts an HTTP request to this resource to create a binary pipe. The response body is a string with the name of a new pipe. Pipe creation is probably triggered by an upload event in a delta request, which describes the files the client wants to upload, although this is not enforced. The server side is allowed to create a binary pipe at any time.
    </p>
    <h4><code>GET &hellip;/pipe/&hellip;</code></h4>
    <p>
A pipe is an HTTP resource in the <code>pipe</code> subdirectory of a paired delta session. The name of the resource was determined when the pipe was created earlier. The server side sends an HTTP request to download files from the pipe resource. The <code>multipart/form-data</code> body of the response encodes the files.
    </p>
    <h4><code>POST &hellip;/pipe/&hellip;</code></h4>
    <p>
The client side of a paired session posts an HTTP request with a <code>multipart/form-data</code> body to upload files to a pipe resource. The pipe name must have been communicated with a push event in a delta response, which instructs the client side to initiate the upload. The pipe name is not stored in the session model with an assignment, because pipes are transient channels. If a browser window is refreshed while uploading files, the upload channels are automatically destroyed.
    </p>
    <p>
The visualization of file uploads in user interfaces of terminals is a responsibility of backend applications. The pipes of a paired session operate independently from the delta messages that the client and server side exchange.
    </p>
    <h3>Download file</h3>
    <p>
The coordination with delta events enables the server side to create a pipe for an uploading client, but a similar coordination cannot be realized for a downloading client. A terminal cannot tell when a browser actually sends an HTTP request to download a file, because it depends on unknown factors, e.g. the volatile state of the browser cache. The URL of a downloaded file would furthermore be confined to a terminal session. Terminals would not be able to share files, even if the terminals belong to the same user.
    </p>
    <p>
A delta session can maintain a directory with cached files. Unlike a binary pipe with a paired reader and writer, a cache has many readers and one writer. Frontend terminals download files from the cache of a backend application. The application fills the cache with files that cannot be published in public library bundles. Cached files have dynamically generated and/or sensitive content, for example financial reports.
    </p>
    <p>
When an HTTP client attempts to download a cached file, the mainframe authenticates the client. The mainframe verifies the request originates from a browser whose user is running the application. If not, the mainframe informs the HTTP client the resource could not be found. If the request is authentic, the user must be authorized to access the cached file. Authorization is coordinated with delta events in the session model of the cache owner, i.e. the backend application. The mainframe generates an event that describes users accessing files. The event conveys a dictionary value that maps file names to <code>Delta.Access</code> records. The boolean field <code>cached</code> is set if the accessed file is present in the cache. Field <code>guests</code> identifies the users that are attempting to download the file.
    </p>
<pre>Delta.Access: {
  cached: boolean,
  guests: [string]
}</pre>
    <p>
The cache owner signals an authorization event back that grants and revokes access to cached files. The event contains a dictionary that maps file names to <code>Delta.Authorization</code> records. The fields <code>allows</code> and <code>denies</code> specify lists of users with authorized and unauthorized access to the cached file.
    </p>
<pre>Delta.Authorization: {
  allows: [string],
  denies: [string]
}</pre>
    <p>
The mainframe can purge cache entries, but it does not maintain a history of purged names. When the mainframe generates an event that describes guests accessing cached files, the mainframe indicates what files are currently in the cache. The cache owner should revoke access to any unknown names it encounters, but it should restore purged files in the cache if their access is granted. The owner must ensure restored files are identical to purged files.
    </p>
    <h4><code>POST &hellip;/alloc</code></h4>
    <p>
A cache owner posts an HTTP request to this resource, when it wants to add a file to the cache. The request body encodes the compact JSON representation of a <code>Delta.Blob</code>. The textual body of the HTTP response is the name of a new cache entry. The allocated name allows the URL of a cached file to be derived before the file content has been copied to the cache.
    </p>
    <h4><code>GET &hellip;/file/&hellip;</code></h4>
    <p>
A frontend terminal is an example of a cache reader. A terminal manifests the URL of a cached file in the DOM, e.g. in an <code>img</code> tag, which causes the browser to send an HTTP request to download the file from the cache. The HTTP response with the file should be cached indefinitely. 
    </p>
    <h4><code>POST &hellip;/file/&hellip;</code></h4>
    <p>
A cache owner posts an HTTP request with a <code>multipart/form-data</code> body to this resource whose name must have been allocated earlier. The form data contains the binary content that should be copied to the cache. The file remains cached until the cache entry is purged or the session of the owner is closed.
    </p>
    <h2>Delta protocol</h2>
    <p>
The following scenarios assume this side of a delta session is an HTTP client. The direction of the delta session is irrelevant unless it is explicitly mentioned. Otherwise, the HTTP client is either the client side of a forward session or the server side of a reverse session. Whatever the role of the HTTP client is, the web server on the other side always plays the opposite role in the delta session. It is furthermore assumed that both sides have successfully parsed and evaluated the type expressions and macros of the typespace.
    </p>
    <h3>Happy days</h3>
    <p>
In the happy days scenario, the sequential exchange of delta messages proceeds without problems.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side. The delta message has a lease time that tells the other side how long it can take to reply with &#x03b4;(n+1).
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
After processing the actions of &#x03b4;(n), the other side replies with &#x03b4;(n+1) before the lease period expires.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n+2)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
This side processes the actions of &#x03b4;(n+1), which also contains a deadline for this side to post &#x03b4;(n+2).
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+3)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies on time with &#x03b4;(n+3), completing another cycle of the delta protocol.
        </p>
      </li>
    </ol>
    <p>
The sequential exchange of messages simplifies the delta protocol. At any given moment, there is one side of the session that has the initiative to produce the next delta message. The lease period of the last delta message sets a deadline for the producing side, ensuring regular contact between both sides.
    </p>
    <h3>Lost delta message</h3>
    <p>
HTTP relies on TCP for reliable message delivery. An HTTP client can however communicate with a server over multiple TCP connections, reordering the flow of HTTP messages. The route between an HTTP client and server may include a number of proxies, further complicating message delivery. The delta protocol assumes the delivery of a message can fail, without receiving a notification of this communication failure before the lease period expires. 
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="bad-side">&perp;</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side, but the delta message never arrives. The client is not notified of this failure before the lease period of &#x03b4;(n) expires.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
When the HTTP client does not receive the expected &#x03b4;(n+1), it polls the session to see what's going on. The poll request is sent when the lease period expires, with some added slack for very small lease periods. The client should not poll the session before the average delay of three network roundtrips has surpassed. 
        </p>
        <p>
If the lease period of &#x03b4;(n) is fairly large, e.g. a minute, it may take a while before the client polls the session to detect problems. An HTTP client can poll the session to seek early confirmation of successful message delivery. When the poll response reveals the other side is expected to produce &#x03b4;(n+1), the client knows &#x03b4;(n) has been delivered.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">expect &#x03b4;(n)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
In this scenario, the poll response reveals the other side is still expecting the HTTP client to post &#x03b4;(n).
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do retry &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
When the HTTP client knows &#x03b4;(n) hasn't arrived at the other side, it aborts the old HTTP request and it posts a new &#x03b4;(n) whose <code>retry</code> flag is set.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The retried &#x03b4;(n) arrives without problems. The other side replies with &#x03b4;(n+1) on time to complete another cycle of the delta protocol.
        </p>
      </li>
    </ol>
    <p>
The previous scenario showed the HTTP client must be able to reproduce &#x03b4;(n) when the last attempt to post &#x03b4;(n) failed. The next scenario shows the other side has the same responsibility after replying with &#x03b4;(n+1). In general, some side of a session should hold on to its last delta message &#x03b4;(m) until it has produced &#x03b4;(m+2) in the next session cycle.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts &#x03b4;(n), which arrives at the other side without problems.
        </p>
      </li>
      <li>
        <span class="bad-side">&perp;</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1) as expected, but this HTTP response is lost.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client polls the session when it does not receive &#x03b4;(n+1) on time.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">expect &#x03b4;(n+2)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The poll response reveals the other side already expects this side to post &#x03b4;(n+2). The HTTP client knows &#x03b4;(n+1) is probably lost.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do retry &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client aborts the old request and it posts a retried &#x03b4;(n). In this scenario, the HTTP client strips all actions from the retried delta message, because it knows the stripped actions have already been processed.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">retry &#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
Although the other side expects &#x03b4;(n+2), it receives a retried &#x03b4;(n). It replies with a retried &#x03b4;(n+1), completely ignoring any actions that the retried &#x03b4;(n) contains.
        </p>
      </li>
    </ol>
    <p>
These scenarios demonstrate the importance of nonitrusive polling. When the HTTP client detects a potential problem, it first polls the session to get an accurate picture of the situation before it reacts, e.g. aborting a previously posted delta message.
    </p>
    <h3>Slow delta message</h3>
    <p>
When a lease period expires, there is not necessarily a real problem. A lease period may not correspond with the actual time it takes to process a delta message. For example, a delta request from a terminal usually specifies a zero lease time, but it is not realistic to assume a backend process can handle all kinds of user interactions almost instantaneously.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts &#x03b4;(n), which arrives at the other side without problems.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client polls the session before it receives &#x03b4;(n+1).
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">expect &#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The poll response reveals the other side is expected to produce &#x03b4;(n+1). The HTTP client can poll the session to seek early confirmation of message delivery when the lease period of &#x03b4;(n) is quite large. In that case, the poll response is a positive confirmation. In the remainder of this scenario, the client polls the session, because the lease period of &#x03b4;(n) has expired. The poll response also reveals &#x03b4;(n+1) is overdue.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client does not abort the posted &#x03b4;(n) when the other side takes too long to produce &#x03b4;(n+1). Polling at regular intervals ensures the loss of &#x03b4;(n+1) is detected.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">expect &#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
Every subsequent poll response reveals the production of &#x03b4;(n+1) takes an increasing amount of time, because the <code>after</code> field of the session status is decreasing as time passes by.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
When the other side finally produces &#x03b4;(n+1), the HTTP client receives a response for the posted &#x03b4;(n) of the first scenario step.
        </p>
      </li>
    </ol>
    <p>
The HTTP client stubbornly waits for the response of the posted &#x03b4;(n). Although an HTTP connection is closed after a certain period of inactivity, it's impossible to predict beforehand when this is going to happen. While repeated polling reveals &#x03b4;(n+1) is still overdue, the HTTP client does not abort the connection. 
    </p>
    <h3>Ready to send next delta message</h3>
    <p>
A ready resource gives the other side control over the lease period, but an HTTP client is not obliged to use it.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1) on time. The lease period, specified in &#x03b4;(n+1), is quite large. The HTTP client has plenty of lease time left after processing the actions of &#x03b4;(n+1).
        </p>      
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">ready<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
In this scenario, the HTTP client sends a ready request to the other side. This side is ready and willing to send the next delta message on demand.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">60 sec<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The ready response from the other side sets a new lease time for this side. The response may take some time to arrive, but it cannot time out. The lease period of &#x03b4;(n+1) already acts as a deadline.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">ready<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
With a lease period of one minute, the HTTP client sends another ready request. It is still ready to send the next delta message.
        </p>
      </li>
    </ol>
    <p>
The HTTP client in the next scenario modifies the model, unlike the client in the previous scenario.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1) on time.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">ready<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client sends a ready request to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n+2)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
Before receiving a ready response, the HTTP client posts &#x03b4;(n+2), because it wants to synchronize the modified model with the other side. The ready response doesn't matter anymore, and the HTTP client aborts the ready request.
        </p>
      </li>
    </ol>
    <p>
The next scenario shows a ready response with a zero lease time.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1) on time.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">ready<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client sends a ready request to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">0 sec<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The ready response from the other side resets the lease time for this side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n+2)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client immediately posts &#x03b4;(n+2) after receiving the ready response, possibly without actions.
        </p>
      </li>
    </ol>
    <p>
Ready messages can get lost. In the next scenario, the ready request is lost, but the story is the same when the ready response is lost.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1) on time.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">ready<br/>&rarr;</span> <span class="bad-side">&perp;</span>
        <p>
The HTTP client sends a ready request that never arrives at the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n+2)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
When the ready request or response fails, the lease period of &#x03b4;(n+1) inevitably expires. Upon expiration, the HTTP client posts &#x03b4;(n+2) to the other side.
        </p>
      </li>
    </ol>
    <p>
The last scenario explains why ready messages are optional. The lease period of a delta message is a safe fallback when ready messages are missing or fail to operate.
    </p>
    <h3>Greedy to receive next delta message</h3>
    <p>
A ready request is a form of courtesy, giving the other side a chance to overrule the lease period of this side. A greedy request is the exact opposite. An HTTP client sends a greedy request in an attempt to reset the remaining lease period of the other side. 
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side. The lease period of &#x03b4;(n) is reasonably large. The other side will have the initiative to synchronize the model for quite a while.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">greedy<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client sends a greedy request.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">28 sec<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The greedy response from the other side is bad news. A greedy HTTP client wants the initiative to synchronize the model, but this greedy response means it may take another 28 seconds before the other side produces &#x03b4;(n+1).
        </p>
      </li>
    </ol>
    <p>
In the next scenario, the greedy request is satisfied before the greedy response arrives.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">greedy<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client sends a greedy request.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1). The HTTP client aborts the greedy request, because it does not matter anymore.
        </p>
      </li>
    </ol>
    <p>
A zero greedy response implies satisfaction is near.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">greedy<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client sends a greedy request.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">0 sec<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The greedy response from the other side is zero. The lease period of the other side has been reset.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1). If it doesn't arrive as promised, the HTTP client polls the session to detect a slow or lost delta message.
        </p>
      </li>
    </ol>
    <p>
The greedy response is lost in the next scenario.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">greedy<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client sends a greedy request.
        </p>
      </li>
      <li>
        <span class="bad-side">&perp;</span> <span class="delta-message">t sec<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The greedy response from the other side is lost.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
When the lease period of &#x03b4;(n) expires, the HTTP client polls the session. It also aborts the greedy request that probably failed. At this point, it doesn't matter whether the greedy request or response failed.
        </p>
      </li>
    </ol>
    <p>
Greedy messages complement ready messages in paired delta sessions. A greedy request in a process session yields a zero ready response in the terminal session, if the terminal has previously sent a ready request. The process in the backend is able to pull the next delta request from the terminal in the frontend, even if the terminal has plenty of lease time left.
    </p>
    <h3>Transfer files through pipe</h3>
    <p>
The transfer of files is coordinated with delta events in a paired session.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(2n+1)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The client side of a paired session posts an HTTP request with &#x03b4;(2n+1) to the server side. The delta request contains an upload event with information about files the client wants to upload.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(2n+2)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The server side replies with &#x03b4;(2n+2). The delta response contains a push event with the name of a binary pipe and the names of files to upload in the pipe.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">pipe &hellip;<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The client posts an HTTP request to the pipe that was named in the push event. The body of the request encodes the uploaded files.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(2n+3)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
While uploading files, the client posts an HTTP request with &#x03b4;(2n+3). Except for the loss in bandwidth, the exchange of delta messages should not be affected by pipe activity.
        </p>
      </li>
    </ol>
    <p>
In the next scenario, the sides are reversed. This side is the downloading server and the other side is the uploading client.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(2n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The server side posts an HTTP request with &#x03b4;(2n) to the client side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(2n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The client side replies with &#x03b4;(2n+1). The delta request contains an upload event with file information.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">plumb<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
In this scenario, the server agrees the files should be uploaded. It posts an HTTP request to create a binary pipe for the file tranfer. 
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&hellip;<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The HTTP response contains the name of a new pipe.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(2n+2)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The server side posts an HTTP request with &#x03b4;(2n+2) whose push event informs the client side about the files to upload in the pipe.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">pipe &hellip;<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The server side sends an HTTP request to download files from the pipe.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(2n+3)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
While downloading files, the server side receives &#x03b4;(2n+3) from the client side.
        </p>
      </li>
    </ol>
    <p>
A binary pipe transfers files from the client to the server side of a paired delta session. The coordination with an upload and push event prepares the downloading server for the uploading client. The coordination also causes a delay, because an extra roundtrip is required to communicate a pipe name before the client kicks off the actual upload. This delay should hardly be noticeable, unless the client and server transfer a lot of small files through separate pipes.
    </p>
    <h3>Publish cached files</h3>
    <p>
A delta session can publish a web directory with cached files. File access is coordinated with delta events in the session of the cache owner, although the coordination is not visible to clients that download cached files. An HTTP client simply sends a request to get a file, regardless whether it's cached or not.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">alloc<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
This side posts an HTTP request to allocate a unique name in the cache that this side owns.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&hellip;<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The HTTP response reveals the name of a new file in the cache. This side can now derive the URL of the cached file.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
This side posts an HTTP request with &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1). The delta message contains an access event, which specifies a user attempting to access the cached file that was allocated earlier.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n+2)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
This side verifies the user is authorized to access the file. It posts &#x03b4;(n+2) to the other side with an authorization event that grants access.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">file &hellip;<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
After the cache owner has granted access to the file, it must post an HTTP request to copy the file content to the cache.
        </p>
      </li>
    </ol>
    <p>
The cache fills up on demand. The content of a cached file is copied when an HTTP client is granted access to download the file, while the content is not yet in the cache. If the content is already cached, this side still authorizes a download attempt, but it should not copy the content again. If this side revokes access, the download of a cached file fails with a status code that indicates the file could not be found. An HTTP client cannot differentiate between a file that is not cached, and a cached file that the client is not authorized to access.
    </p>
    <p>

    </p>
    <h3>Close session</h3>
    <p>
Delta sessions do not live forever. The next scenario shows how a session is closed.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1) on time.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(-2)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
This side decides to close the session. The HTTP client posts &#x03b4;(-2) to tell the other side the session should be closed. The delta message does not contain actions and it defines a zero lease time.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(-1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(-1) to acknowledge the session has been closed. This delta message also lacks actions.
        </p>
      </li>
    </ol>
    <p>
In the next scenario, the other side unexpectedly closes the session.
    </p>
    <ol>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(n+1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(n+1).
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">do &#x03b4;(n+2)<br/>&rarr;</span> <span class="delta-side">other</span>
        <p>
The HTTP client posts a request with &#x03b4;(n+2) to the other side.
        </p>
      </li>
      <li>
        <span class="delta-side">this</span> <span class="delta-message">&#x03b4;(-1)<br/>&larr;</span> <span class="delta-side">other</span>
        <p>
The other side replies with &#x03b4;(-1) to inform the session has been closed.
        </p>
      </li>
    </ol>
    <p>
A closed session does not leave any traces. All attempts to access a session resource will fail after the session has been closed.
    </p>
    <h3>Dead session</h3>
    <p>
In the previous scenarios, a session is polled to determine how a problem might be fixed. A polling operation can of course also fail, demonstrated by the session in the next scenario.
    </p>
    <ol>
      <li>
      <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="bad-side">&perp;</span>
      <p>
The HTTP client sends a poll request, but it does not receive a suitable response. It does not matter whether the client does not receive a response at all, or whether the response reports a request failure.
      </p>
      </li>
      <li>
      <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="bad-side">&perp;</span>
      <p>
After waiting for at least three seconds, the HTTP client polls the session again. If it is still expecting a poll response from the previous attempt at this point, the unresponsive request is aborted.
      </p>
      </li>
      <li>
      <span class="delta-side">this</span> <span class="delta-message">poll<br/>&rarr;</span> <span class="bad-side">&perp;</span>
      <p>
After another three seconds, the HTTP client polls the session for the last time. In this case, the situation remains bleak.
      </p>
      </li>
    </ol>
    <p>
If a session is unresponsive after three poll attempts, this side can safely conclude the session is dead. The delta protocol does not define how the HTTP client should react to a dead session. It's possible the client decides to die with the session. This kind of escalation behavior is outside the scope of the protocol.
    </p>
    <h1>Welcome service</h1>
    <p>
The welcome service of an open mainframe serves the HTTP request of a browser that navigates to a welcome URL. The HTTP response is an HTML page with JavaScript code inside to initialize the runtime environment of a terminal. When the runtime environment has installed the application image, the terminal opens the session. The manifestation of the session model subsequently creates a user interface that is presented in the browser. At this point, the terminal only needs the delta service to synchronize the virtual user interface with the mainframe. This chapter explains how web browsers become terminals.
    </p>
    <h2>Welcome URL</h2>
    <p>
Many web applications use cryptic URLs to store all kinds of state, e.g. session identifiers, application names and release versions. Although oma uses these ugly URLs internally as well, a welcome URL deserves special attention, because it involves a user experience. A user that bookmarks a welcome URL in a browser, expects to see a similar user interface when the bookmark is activated later on. The user is definitely not interested in expired sessions or version mismatches. The open mainframe architecture treats a welcome URL as a contract with end users. Welcome URLs are first and foremost intended to offer a good user experience.
    </p>
    <p>
When a browser navigates to a welcome URL, the welcome service has to decide which deployed application is responsible for the user interface of a terminal. An application deployment subscribes itself to prefixes of welcome URLs that it wishes to associate with the application. The welcome service examines these subscriptions to link a welcome request to a deployed application. If the path of a welcome URL matches multiple subscriptions, the subscription of the most recently deployed application wins the conflict.
    </p>
    <p>
The subscription mechanism simplifies application management in oma. An application subscribes to welcome URLs that seem suitable for the particular type of deployment. Suppose a webshop application is deployed on a production site. This deployment welcomes terminals that visit URLs like <code>search/shirt</code>, which look meaningful to end users. When a developer deploys the same webshop application on a test site, the deployment subscribes to welcome URLs that start with <code>_/app/AiQ9x/</code>. The ugliness does not disappoint a user in this case, because the developer is well aware the URLs belong to a temporary deployment.
    </p>
    <p>
Welcome URLs generally belong to one of the following categories.
    </p>
    <ul>
      <li>
        <p>domain entity</p>
        <p>
A welcome URL selects an entity from an application domain. The path of the URL starts with the domain name, followed by selection criteria to identify an entity, e.g. <code>shirt/53928</code>. Users expect these welcome URLs to last on production sites. They are convenient targets for bookmarks and for hyperlinks in HTML documents. 
        </p>
      </li>
      <li>
        <p>domain partition</p>
        <p>
The welcome URL of an entity in a flat domain does not convey implementation details about the backend. However, if the backend already partitions the domain in distinct chunks, e.g. geographically, the partition of an entity is an obvious prefix for a welcome URL. For example, when a browser navigates to URL <code>us/search/shirt</code>, the terminal starts the US version of the webshop. The URL <code>de/suchen/hemd</code> starts the German version. These welcome URLs are expected to last on production sites, but the current partition scheme may not the best scheme in the future. Users will be disappointed if a company changes welcome URLs after a major reorganization. 
        </p>
      </li>
      <li>
        <p>test release</p>
        <p>
Welcome URLs should last on production sites, but not necessarily on test sites. A user understands the welcome URL of a test application is not everlasting, although welcome URLs of common test releases, e.g. a beta release, may be an exception. The user interface should clearly indicate the user is running a test version of the application to prevent confusion with the production site.
        </p>
      </li>
      <li>
        <p>temporary deployment</p>
        <p>
These welcome URLs are suitable for developers. They deploy and test many applications at cryptic, temporary welcome URLs. They may chat a welcome URL to another coworker to demonstrate a problem, but they also understand the specific test application must still be deployed when the coworker navigates a browser to the URL.
        </p>
      </li>
    </ul>
    <p>
The welcome request of a terminal may pass through proxies before it arrives at a mainframe. Proxies rewrite URLs in HTTP requests, which is problematic for welcome requests, because the welcome URL in the address bar is part of the session model. It's possible for a backend process to assume the browser of the terminal displays welcome URL <code>shirt/28471</code>, whereas the browser actually displays <code>foo/shirt/28471</code>. The extra <code>foo/</code> prefix has been added by a proxy between the terminal and the mainframe. A mainframe may disallow the use of proxies, and redirect an offending browser to a proper welcome URL. The redirection is also necessary if cookies are scoped to subdomains. The Same-Origin-Policy of browsers requires the welcome URL to stem from the same domain as the subdomains of new cookies. Production sites rely on subdomains to balance incoming HTTP traffic. If proxies are allowed between a terminal and a mainframe, the potential discrepancy between a welcome URL in the address bar and in the session model must be taken into account. The <dfn>welcome root</dfn> of a terminal is an extra path prefix that is displayed in the address bar. Terminals strip the root prefix from welcome URLs in session models. Backend applications are not bothered by HTTP proxies.
    </p>
    <h2>Boot terminal</h2>
    <p>
When the welcome service knows which backend application is subscribed at a welcome URL, the service generates an HTML document for the browser. The HTML document should not contain sensitive information, e.g. a descriptive title of the domain entity, because the welcome service does not authenticate the welcome request. Everybody receives the same welcome response for a welcome URL, as long as the same application deployment remains subscribed at the given URL.
    </p>
    <p>
The generated HTML document is the first stage to boot a terminal. In the second stage, the terminal loads all assets it requires to present the real user interface of a backend process. In the final stage, the terminal opens the terminal session to obtain the model of the virtual user interface. The end user however expects a visual clue that the application is running in the browser, before the terminal manifests the session model and presents the user interface in the last stage. This is especially important on mobile networks with significant latencies. The HTML document is treated as a splash screen that postpones the execution of JavaScript files. The browser first loads other resources that specify the initial appearance of the application. 
    </p>
    <p>
The next example shows a typical welcome response. After setting the base URL to match the mainframe root, the head section defines links to CSS style sheets. The head also inlines a small style sheet. The body section contains the <dfn>display element</dfn> where the virtual user interface of the session model will be manifested in the DOM later on. Until that happens, the display element presents the splash content. The body section ends with several script tags, which initialize the runtime environment of the terminal. In the last inline script, the loader of the runtime environment installs the application image. One of the modules in the application image opens or restores the terminal session whose model is manifested in the DOM.
    </p>
<pre>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"/&gt;
    &lt;base href="../../../"/&gt;
    &lt;link rel="stylesheet" href="_/pub/oma-runtime-browser/1.3.5/1/reset.css"/&gt;
    &lt;style&gt;&hellip;&lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="oma"&gt;&hellip;&lt;/div&gt;
    &lt;script src="_/pub/oma-runtime-system/1.3.2/load.js"&gt;&lt;/script&gt;
    &lt;script src="_/pub/oma-runtime-browser/1.3.5/load.js"&gt;&lt;/script&gt;
    &lt;script&gt;&hellip;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
    <h2>Open or restore session</h2>
    <p>
The welcome service cannot tell whether a welcome request originates from a new or existing terminal. When a terminal boots, it must either open a new session or restore the old session. Terminals employ the session storage of HTML5 browsers to distinguish between these scenarios. The session storage survives a browser refresh. A terminal adds information to this storage after successfully opening a new terminal session to start an application. If a booting terminal retrieves this information, it knows how to restore the session. Otherwise it must open a new terminal session.
    </p>
    <p>
A terminal opens a session by dynamically adding a script tag whose URL parameters supply the welcome service with information about the terminal that cannot be derived from the welcome request.
    </p>
    <ul>
      <li>
        <p>
welcome URL (<code>ref</code>)
        </p>
        <p>
The URL of a welcome request does not include the hash fragment that is displayed in the address bar. The fragment is also missing from URLs in the <code>Referer</code> header of HTTP requests. An explicit script parameter with the full welcome URL corrects this omission.
        </p>
      </li>
      <li>
        <p>
backend application identity (<code>app</code>)
        </p>
        <p>
A welcome response contains code to load the image of a particular backend application, but a browser may use a cached welcome response after the application has been undeployed. A script parameter supplies the unique identity of the deployed application. When the welcome service is asked to open a new terminal session, it verifies the application is still deployed. If not, the terminal must fetch a fresh welcome response.
        </p>
      </li>
      <li>
        <p>
terminal identity (<code>tty</code>)
        </p>
        <p>
A script parameter specifies an optional identity, when the terminal opens a session to start an application. The welcome service needs this identity to distinguish between an existing terminal that starts a new application, and a new terminal that starts the first application.
        </p>
      </li>
    </ul>
    <p>
The script resource to open a terminal session is located at <code>_/start</code>, relative from the base URL. A browser sends an HTTP request with script parameters to get JavaScript source code from this resource. The corresponding HTTP response may issue cookies with <code>Set-Cookie</code> headers. The welcome service associates several cookies with a terminal. The <dfn>device identity</dfn> is a persistent cookie that tracks the browser of a terminal. The <dfn>guest identity</dfn> and <dfn>guest ticket</dfn> are transient cookies that authenticate the user of a terminal. The welcome service issues the guest cookies once, but the device cookie is renewed whenever guest cookies are issued. The combination of guest identity and ticket proves terminals belong to a unique person, although the welcome service does not know what this person is allowed to do.
    </p>
    <p>
The welcome service protects the confidentiality of guest tickets, because they resemble temporary passwords. The service does not store plain guest tickets to limit the damage of a compromised guest administration. When the service issues guest cookies, it computes a hash-based authentication code of the guest identity with a secret ticket, which is stored with the guest identity. An HTTP request is considered authentic if the ticket cookie reproduces the hash that was stored with the guest identity.
    </p>
    <p>
When a user navigates the first terminal to a welcome URL on a mainframe, the welcome service issues the device and guest cookies of the terminal. When a second terminal is opened in a new browser window but still on the same mainframe, both terminals share their device and guest cookies. This improves the user experience, because the user is not forced to login twice. The guest cookies are automatically removed upon closing all browser windows. This ensures the user does not leave any traces behind that could be abused to steal credentials.
    </p>
    <h2>Manifest session model</h2>
    <p>
The last stage of a booting terminal manifests the session model to present a real user interface in the browser. The stage starts when the browser is installing the application image. If the browser is still loading the script to open the session, the terminal must wait for this script to complete, because the script persists the location of the terminal session in the HTML5 session storage of the browser.
    </p>
    <p>
A booting terminal retrieves its session URL from the HTML5 session storage. Armed with the URL, the terminal sends an HTTP request to get a JSON dump of the session. The dump reveals the complete state of a virtual user interface, which the terminal should present in the browser. If the terminal is restoring an existing session, the user interface continues in the state where the terminal left the application the last time. If the terminal has just opened a new session, the virtual user interface is in an indeterminate state. When the backend process produces delta response &#x03b4;(0) with an initial virtual user interface, it doesn't know whether the terminal device is a mobile smartphone with touch support, a laptop with keyboard and mouse support, or some other device. Session values whose manifestations rely on specific device features must appear in delta response &#x03b4;(2) or later, because a terminal reports supported device features in delta request &#x03b4;(1).
    </p>
    <p>
When the session dump is available, the terminal waits for the installation of the application image to finish. This ensures the terminal has loaded all modules, which are required to manifest the session model. Module configurations bind data types to manifestation classes. If the dynamic type of a session value is bound to a manifestation class, an object of this class is created. The new manifestation object implements the intended behavior of the session value in the browser environment, e.g. real button and slider controls in the browser DOM that synchronize session values.
    </p>
    <h1>Deploy service</h1>
    <p>
A backend application contacts the deploy service of an open mainframe to enable frontend terminals to start the application. This chapter explains what the mainframe expects from a backend application to achieve successful deployment.
    </p>
    <h2>Application image</h2>
    <p>
An application image lists all modules of an application. A booting terminal installs an image from the compact JSON representation of an <code>App.Image</code> value. Field <code>bundles</code> is a dictionary that maps a bundle name to the URL where the bundle is published. Field <code>modules</code> maps a module name to a record value of type <code>App.Module</code>.
    </p>
<pre>App.Image: {
  bundles: &lt;string&gt;,
  modules: &lt;App.Module&gt;
}</pre>
    <p>
Modules serve many purposes in oma. They contain class definitions, data type definitions, binary assets, etc. An <code>App.Module</code> value concentrates on the information that is necessary to decide if and when a terminal should load a module. Field <code>bundle</code> identifies the bundle that contains the module. The ordinal index of a module is contained in field <code>index</code>.  The location of a module is derived from the URL of the bundle and the ordinal index of the module in this bundle. If version 2.3.7 of bundle <code>foo</code> is published at <code>_/pub/foo/2.3.7</code>, the first module is located at <code>_/pub/foo/2.3.7/1</code>. Field <code>dependencies</code> lists names of modules. A module must be loaded after the dependencies have been loaded. Cyclic dependencies are not allowed. Field <code>optional</code> indicates whether a module can be unloadable, although all dependencies have been successfully loaded. Loading an optional module may require support for a particular device feature, e.g. audio playback, which the runtime environment does not offer.
    </p>
<pre>App.Module: {
  bundle: string,
  index: number,
  depends: [string],
  optional: Flag
}</pre>
    <h2>Light deployment</h2>
    <p>
An HTTP client deploys a backend application with a POST request to resource <code>_/deploy</code>. A deploy request specifies the bundles that make up the application image. The body of deploy request contains the compact JSON representation of an <code>App.Deploy</code> value if the deployment is light. Field <code>bundles</code> maps a bundle name to a version. Field <code>welcomes</code> lists the patterns of welcome URLs to which the application wants to subscribe. Field <code>temporary</code> affects the welcome root of terminals that start the application. The byte size of the file cache is optionally specified in field <code>cache</code>.
    </p>
<pre>App.Deploy: {
  bundles: &lt;string&gt;,
  welcomes: [string],
  temporary: Flag,
  cache: number?
}</pre>
    <h2>Heavy deployment</h2>
    <p>
A heavy deployment 
    </p>
    <h2>Application session</h2>
    <p>
The application session is located at <code>_/mount/<span class="variable">id</span></code> in the backend.
    </p>
<pre>App.Session: {
  start: &lt;App.Launch&gt; @event=server,
  download: &lt;Delta.Access&gt; @event=server,
  authorize: &lt;Delta.Authorization&gt; @event=client,
}
App.Launch: {
  guest: string,
  terminal: string,
  welcome: string
}</pre>
    <h2>Frontend exposure</h2>
    <p>
After successful deployment, the application is exposed at <code>_/app/<span class="variable">id</span></code> in the frontend.
    </p>
    <h1>Library service</h1>
    <h1>Diagnostics service</h1>
    <h1>Virtual user interface</h1>
    <p>
The virtual user interface of oma describes basic features that any real user interface in a terminal must be able to support. This boils down to HTML features, because terminals are web browsers. However, HTML was not designed to construct consistent user interfaces. HTML is very rich and expressive, which is an invitation for developers to tweak the HTML markup of user intefaces, until they are pixel-precise replicas of mock-ups. In theory, CSS is a powerful instrument to separate styling from HTML markup. The harsh reality is that the amount of CSS classes, rules and properties in web applications quickly explodes to incomprehensible proportions. If developers are not careful, CSS preprocessors only worsen the situation with more bloated style sheets. The philosophy of CSS envisions cooperation between team members to develop a solid strategy, but CSS is too often an afterthought in projects.
    </p>
    <p>
The virtual user interface borrows heavily from HTML and CSS. It is an attempt to take the good parts of these technologies and to drop the smelly parts. The final result, discussed in this chapter, should improve cooperation between all team disciplines that are involved in the construction of user interfaces, both virtual and real.
    </p>
    <h2>Default toolkit</h2>
    <p>
A virtual user interface is built from a tree of widgets. A <dfn>widget</dfn> is a user interface control with a clear purpose. Widgets are defined in toolkits, and the default toolkit defines the minimal set of widgets that work on all terminal devices.
    </p>
    <h3>Widget</h3>
    <p>
A virtual widget is a <code>UI.Widget</code> record value. When <code>hidden</code> is truthy, the widget should not be manifested in the browser DOM. If a DOM manifestation already exists, it must either be removed or its CSS <code>display</code> property must be set to <code>none</code>. Field <code>style</code> contains <code class="literal">null</code>, a style class name, or a list with style class names. These names are mapped to one or more CSS class names in the DOM. Optional numeric field <code>index</code> determines the presentation order of a widget when it's part of a dictionary composition.
    </p>
<pre>UI.Widget: {
  hidden: Flag,
  style: UI.Style?,
  index: number?
}
UI.Style: string | [string]</pre>
    <p>
Virtual widgets roughly fall into four categories, although a concrete widget type may combine features from several categories. A <dfn>layout widget</dfn> specifies a layout strategy for child widgets. The composition of children is either a list or dictionary with widget values. A <dfn>decorator widget</dfn> adds features to another widget, the <code>subject</code>. An <dfn>output widget</dfn> displays a text or image in a virtual user interface, with a symbolic identifier for localization purposes. An <dfn>input widget</dfn> captures real user interactions and translates them to delta actions on a virtual widget, but only when it's enabled. An interactive input widget may need exclusive focus. An unchained widget is dropped from the list of  focusable widgets in the DOM, which a user can traverse, for example with <code>tab</code> and <code>alt-tab</code> keys on terminal devices with keyboards. When the user presses a key on the keyboard, the input widget with focus generates a client event.
    </p>
<pre>UI.Layout(T=UI.Widget): UI.Widget + {
  widgets: UI.Composition(T)?
}
UI.Composition(T=UI.Widget): [T] | &lt;T&gt;
UI.Decorator(T=UI.Widget): UI.Widget + {
  subject: T?
}
UI.Output: UI.Widget + {
  symbol: string?
}
UI.Input: UI.Widget + {
  disabled: Flag,
  unchained: Flag,
  focus: boolean @event=client @delay=forever,
  autofocus: none @event=server,
  keypress: UI.Keypress @event=client @delay=forever
}</pre>
    <h3>Layout</h3>
    <p>
A virtual widget does not specify a size. The 2D area that a virtual widget occupies in a user interface, is intrinsically driven by the content and styling of the widget, except for sizeable widgets with an explicit height or width. A sizeable widget without a height or width automatically grows and shrinks to accommodate for its content. Otherwise, the size of a sizeable widget is either fixed at a CSS length, or proportional to the size of the parent widget.
    </p>
<pre>UI.Sizeable: { height: UI.Size?, width: UI.Size? }
UI.Size: UI.Length | number
UI.Length: { n: number, u: "ch"_"em"_"ex"_"px"_"rem" }</pre>
    <p>
A <dfn>widget frame</dfn> is a sizeable display surface for a child subject and a layout for child magnets. A <dfn>magnet frame</dfn> has an absolute position, relative to the top left corner of the parent frame. A numeric top or left is proportional to the size of the parent. A negative magnet height or width, whether fixed-length or proportional, is subtracted from the distance to the opposite side of the parent frame. For example, if <code>left</code> is fixed at ten pixels, and <code>width</code> is minus ten percent (<code>-0.1</code>), the right side of a magnet is positioned at ninety percent of the parent's width. A horizontal or vertical translation positions the magnet at its final location. A numeric translation is proportional to the size of the magnet.
    </p>
<pre>UI.Frame: UI.Sizeable + UI.Decorator + UI.Layout(UI.Magnet)
UI.Magnet: UI.Frame + {
  left: UI.Size?, top: UI.Size?,
  translateX: UI.Size?, translateY: UI.Size?
}</pre>
    <p>
The items in a sizeable <dfn>widget list</dfn> either flow horizontally in rows or vertically in columns. The layout of list items is controlled with CSS flexbox features. Unless specified differently, items flow from left to right in Latin writing mode, they wrap in multiple rows from top to bottom, they are left-aligned in a row, they stretch to fit the row height, and when there are multiple rows, the rows stretch to fit the list height.
    </p>
<pre>UI.List: UI.Sizeable + UI.Layout(UI.Item) + {
  direction: UI.Flow.Direction?,
  wrap: UI.Flow.Wrap?,
  justify: UI.Flow.Justify?,
  alignItems: UI.Flow.AlignItems?,
  alignContent: UI.Flow.AlignContent?
}</pre>
    <p>
Items in a list flow from right to left with <code>rowReverse</code> direction, from top to bottom with a <code>column</code> direction, and from bottom to top with a <code>columnReverse</code> direction.
    </p>
<pre>UI.Flow.Direction: "rowReverse"_"column"_"columnReverse"</pre>
    <p>
A list wraps items by default, unless overruled with <code>overflow</code>. If there are too many items to fit in one row or column, the list will overflow horizontally or vertically. When a list wraps items in the <code>reverse</code> direction, multiple rows or columns are positioned in reverse order. For example, a list with row direction that needs two rows to layout items, contains the last items in the first row and the first items in the second row.
    </p>
<pre>UI.Flow.Wrap: "overflow"_"reverse"</pre>
    <p>
Field <code>justify</code> controls how a list distributes empty space between items on the direction axis. For example, items in a list with a row direction are left-aligned by default, right-aligned with <code>opposite</code>, horizontally centered with <code>center</code> and evenly distributed in a row with <code>between</code> and <code>around</code>.
    </p>
<pre>UI.Flow.Justify: "opposite"_"center"_"between"_"around"</pre>
    <p>
Field <code>alignItems</code> specifies alignment of items, perpendicular to the direction axis, i.e. vertical alignment of row items or horizontal alignment of column items. By default, items are not aligned, stretching to row height or column width. Otherwise, they are compactly aligned with <code>start</code>, <code>end</code>, <code>center</code> or <code>baseline</code>.
    </p>
<pre>UI.Flow.AlignItems: "start"_"end"_"center"_"baseline"</pre>
    <p>
Field <code>alignContent</code> specifies how a list distributes empty space between multiple rows or columns. It is ignored when the list has one row or column. By default, rows stretch to cover the list height and columns stretch to cover the list width. Otherwise, they are compactly aligned with <code>start</code>, <code>end</code>, <code>center</code>, <code>between</code> or <code>around</code>.
    </p>
<pre>UI.Flow.AlignContent: "start"_"end"_"center"_"between"_"around"</pre>
    <p>
A <dfn>list item</dfn> decorates a subject that flows in a list layout. Optional fields <code>grow</code>, <code>shrink</code> and <code>basis</code> specify flexibility of an individual list item. Perpendicular alignment of a list item is overruled with field <code>align</code>.
    </p>
<pre>UI.Item: UI.Decorator + {
  grow: number?,
  shrink: number?,
  basis: UI.Size?,
  align: UI.Flow.Align?
}
UI.Flow.Align: "stretch" | UI.Flow.AlignItems</pre>
    <h3>Output</h3>
    <p>
A <dfn>text widget</dfn> displays lines of text inside a virtual user interface. The bounding box of the widget grows and shrinks to wrap the text, unless style classes restrict the width of the box and also prevent line wrapping.
    </p>
<pre>UI.Text: UI.Output + {
  line: Text?
}</pre>
    <p>
An <dfn>image widget</dfn> adds graphics to a virtual user interface. Field <code>asset</code> contains the mandatory URL where the binary asset is located.
    </p>
<pre>UI.Image: UI.Output + {
  asset: string
}</pre>
    <p>
An <dfn>icon widget</dfn> resembles a list with an image and text widget, whose direction can be specified. An icon with the default row direction flows the image and text from left to right. The image and text are compactly aligned from the start of the direction axis, and they are centered, perpendicular to this axis.
    </p>
<pre>UI.Icon: UI.Image + UI.Text + {
  direction: UI.Flow.Direction?
}</pre>
    <h3>Input</h3>
    <p>
A <dfn>scroll input</dfn> pins a viewport to the display surface of the decorated subject. The viewport selects the visible portion when the display surface is too large. Horizontal and vertical scroll offsets are proportional to size differences. For example, if <code>scrollY</code> is <code>0</code>, the top of the viewport aligns with the top of the surface. If <code>scrollY</code> is <code>1</code>, the bottom of the viewport aligns with the bottom of the surface.
    </p>
<pre>UI.Scroll: UI.Input + UI.Decorator + {
  scrollX: number? @data=both @delay=flush,
  scrollY: number? @data=both @delay=flush
}</pre>
    <p>
A <dfn>button widget</dfn> decorates a subject widget with a click feature to activate or select the subject. Most buttons decorate an output widget, e.g. an icon. Although it's possible to nest another interactive widget inside a button, it should be avoided, because it looks and feels confusing.
    </p>
<pre>UI.Button: UI.Input + UI.Decorator + {
  click: UI.Click @event=client @delay=forever
}</pre>
    <p>
A <dfn>navigation button</dfn> is a hyperlink that navigates the terminal to a new URL, contained in field <code>jump</code>,  when the user activates the hyperlink.
    </p>
<pre>UI.NavButton: UI.Button + {
  jump: string
}</pre>
    <p>
A <dfn>command button</dfn> initiates a blocking operation. The user interface is unresponsive after activating the button, until the server side has processed the click event.
    </p>
<pre>UI.CmdButton: UI.Button + {
  click: UI.Click @event=client @delay=block
}</pre>
    <p>
A user interacts with a <dfn>selection widget</dfn> to make a choice. A <dfn>choice widget</dfn> is a special button that is always unchained. The parent selection determines how focus programmatically switches between choice buttons, for example with arrow keys on a keyboard.
    </p>
<pre>UI.Selection: UI.Input + UI.Layout(UI.Choice)
UI.Choice: UI.Button + {
  unchained: none,
  selected: Flag
}</pre>
    <p>
A <dfn>radio list</dfn> selects at most one radio button. Radio buttons cannot be deselected by the user. The list automatically deselects a radio button when the user selects another button from the list. The default direction of a radio list flows the buttons from left to right in a row. 
    </p>
<pre>UI.RadioList: UI.Selection + {
  direction: UI.Flow.Direction?
}</pre>
    <p>
A <dfn>check list</dfn> selects zero or more checkboxes. The direction specifies how checkboxes flow in the check list, similar to a radio list.
    </p>
<pre>UI.CheckList: UI.Selection + {
  direction: UI.Flow.Direction?
}</pre>
    <p>
A <dfn>cycle button</dfn> decorates the current choice. Although a cycle button appears to nest buttons, which is generally a bad idea, only one choice is ever visible. When the user presses the button, the decorated subject is replaced by the next choice from the selection. The behavior of cycle buttons is similar to how radio lists behave, but cycle buttons take up less space in the user interface. They are convenient controls if there are a few obvious choices.
    </p>
<pre>UI.CycleButton: UI.Selection + UI.Button</pre>
    <h2>Style classes</h2>
    <h1>Appendix</h1>
    <h2>HTTP</h2>
    <h3><span class="variable">welcome</span></h3>
    <p>
If a URL does not start with an underscore, it is a treated as a welcome URL.
    </p>
    <h3>_/deploy</h3>
    <p>
Deploy a backend application. Light deployment posts a JSON object. Heavy deployment uploads JSON object and a source archive.
    </p>
    <h3>_/start</h3>
    <p>
Open terminal session and start application in browser. The GET response contains JavaScript code to persist info about terminal session in the browser, using HTML5 session storage.
    </p>
    <h3>_/publish</h3>
    <p>
Publish new library bundle. Assets in uploaded source archive are compiled and copied to directory on a web server.
    </p>
    <h3>_/pub/<span class="variable">bundle</span>/<span class="variable">version</span>/load.js</h3>
    <p>
JavaScript loader to install particular version of the bundle.
    </p>
    <h3>_/pub/<span class="variable">bundle</span>/<span class="variable">version</span>/<span class="variable">module</span>/&hellip;</h3>
    <p>
Access compiled asset from a module. The module is identified by an ordinal index inside the versioned bundle. Path remainder locates asset inside module.
    </p>
    <h3>_/mount/<span class="variable">app-id</span>/<span class="variable">operation</span></h3>
    <p>
Initiate delta session operation in an application session. It lacks support for ready/greedy messages and file transfers with pipes. It includes support for publishing files in cache.  
    </p>
    <h3>_/proc/<span class="variable">proc-id</span>/<span class="variable">operation</span></h3>
    <p>
Initiate delta session operation in a process session. It supports greedy messages, pipe creation and pipe downloading. Ready messages and cached files are not supported.
    </p>
    <h3>_/tty/<span class="variable">tty-id</span>/<span class="variable">app-id</span>/<span class="variable">operation</span></h3>
    <p>
Initiate delta session operation in a terminal session. Terminal session supports ready messages and pipe uploading. Greedy messages and cached files are not supported.
    </p>
    <h3>_/app/<span class="variable">app-id</span>/<span class="variable">welcome</span></h3>
    <p>
Welcome URL for temporary deployment of a test application.
    </p>
    <h3>_/app/<span class="variable">app-id</span>/_/file/<span class="variable">name</span></h3>
    <p>
Get file from application cache. A terminal is authenticated and authorized before it can access a cached file.
    </p>
    <h3>_/app/<span class="variable">app-id</span>/_/pub/<span class="variable">module</span>/&hellip;</h3>
    <p>
Access compiled asset from module in heavy deployment.
    </p>
  </body>
</html>
